<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu 18.04开启bbr]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2Fubuntu%2018.04%E5%BC%80%E5%90%AFbbr%2F</url>
    <content type="text"><![CDATA[说明：Ubuntu 18.04前几天发布了，改变挺大的，内核也直接升到了正式版4.15，而BBR内核要求为4.9，也就是说满足了，所以我们不需要换内核就可以很快的开启BBR，这里简单说下方法。 方法1、修改系统变量 echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf 2、保存生效 sysctl -p 3、查看内核是否已开启BBR sysctl net.ipv4.tcp_available_congestion_control 显示以下即已开启： # sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 4、查看BBR是否启动 lsmod | grep bbr 显示以下即启动成功： # lsmod | grep bbrtcp_bbr 20480 14 原文链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xshell调整tmux大小无效问题]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FXshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由screen转tmux，使用的时候发现tmux的pane大小只能左右调节不能上下调节，各种搜索后发现是xshell的问题，xshell这个坑竟然不响应ctrl+up和ctrl+down。。。 两个组合键输出的特殊字符是[1;5A和[1;5B，其中是一个代表esc的特殊字符。复制输出的字符串，xshell工具-&gt;选项-&gt;键盘和鼠标-&gt;编辑-&gt;新建，按ctrl+up，类型选择发送字符串，粘贴刚才复制的对应字符串，完成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[tmux常用命令以及快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2Ftmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[命令行 tmux new[-session] -s $session_name -d 新建会话(-d 是否在后台) tmux new -s name -n $window_name 新建会话及窗口 tmux at[tach] -t session 重新连接(-t 后接会话名称) tmux ls 显示保存的会话 tmux kill-session -t $session_name 删除会话 内部命令prefix: ctrl+bprefix `&#123; / &#125;` 左右pane交换prefix `&quot;`: 上下分割prefix `%`: 左右分割prefix `方向键`: focus到相应的panel上prefix `o`: focus 到下一个pannel上 prefix `d`: 推出并保存工作区 `tmux attach` 恢复prefix `&amp;`: 关闭工作区，无法保存prefix `:kill-session`: 关闭当前sessionprefix `d`: 临时退出sessionprefix `:kill-server`: 关闭所有session]]></content>
  </entry>
  <entry>
    <title><![CDATA[NERD tree 配置命令以及快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FNERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[NERD tree 配置使用F2快速展开或隐藏它打开vim时自动展开NERDTree autocmd vimenter * if !argc() | NERDTree | endif 如果窗口除了NERDTree没有其他文件时，自动关闭，可以减少多次按:q autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTreeType") &amp;&amp; b:NERDTreeType == "primary") | q | endif 使用F2快速展开或隐藏它 map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt; 命令:tabnew [++opt选项] ［＋cmd］ 文件 建立对指定文件新的tab:tabc 关闭当前的 tab:tabo 关闭所有其他的 tab:tabs 查看所有打开的 tab:tabp 前一个 tab:tabn 后一个 tab 快捷键shift + a 侧边栏宽度放大，再按一下恢复ctrl + w + h 光标 focus 左侧树形目录ctrl + w + l 光标 focus 右侧文件显示窗口ctrl + w + w 光标自动在左右侧窗口切换 #！！！ctrl + w + r 移动当前窗口的布局位置o 在已有窗口中打开文件、目录或书签，并跳到该窗口go 在已有窗口 中打开文件、目录或书签，但不跳到该窗口t 在新 Tab 中打开选中文件/书签，并跳到新 TabT 在新 Tab 中打开选中文件/书签，但不跳到新 Tabi split 一个新窗口打开选中文件，并跳到该窗口gi split 一个新窗口打开选中文件，但不跳到该窗口s vsplit 一个新窗口打开选中文件，并跳到该窗口gs vsplit 一个新 窗口打开选中文件，但不跳到该窗口! 执行当前文件O 递归打开选中 结点下的所有目录x 合拢选中结点的父目录X 递归 合拢选中结点下的所有目录e Edit the current dif双击 相当于 NERDTree-o中键 对文件相当于 NERDTree-i，对目录相当于 NERDTree-eD 删除当前书签P 跳到根结点p 跳到父结点K 跳到当前目录下同级的第一个结点J 跳到当前目录下同级的最后一个结点k 跳到当前目录下同级的前一个结点j 跳到当前目录下同级的后一个结点C 将选中目录或选中文件的父目录设为根结点u 将当前根结点的父目录设为根目录，并变成合拢原根结点U 将当前根结点的父目录设为根目录，但保持展开原根结点r 递归刷新选中目录R 递归刷新根结点m 显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等cd 将 CWD 设为选中目录I 切换是否显示隐藏文件f 切换是否使用文件过滤器F 切换是否显示文件B 切换是否显示书签q 关闭 NerdTree 窗口? 切换是否显示 Quick Help标准模式下：gT 前一个 tabgt 后一个 tabMacVim 还可以借助快捷键来完成 tab 的关闭、切换cmd+w 关闭当前的 tabcmd+&#123; 前一个 tabcmd+&#125; 后一个 tab ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim常用快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2Fvim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[v：按字符选择。经常使用的模式，所以亲自尝试一下它。V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。一、移动光标1、左移h、右移l、下移j、上移k2、向下翻页ctrl + f，向上翻页ctrl + b3、向下翻半页ctrl + d，向上翻半页ctrl + u4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^5、移动光标到下一个句子 ），移动光标到上一个句子（6、移动到段首&#123;，移动到段尾&#125;7、移动到下一个词w，移动到上一个词b8、移动到文档开始gg，移动到文档结束G9、移动到匹配的&#123;&#125;.().[]处%10、跳到第n行 ngg 或 nG 或 :n11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L12、读取当前字符，并移动到本屏幕内下一次出现的地方 *13、读取当前字符，并移动到本屏幕内上一次出现的地方 #二、查找替换1、光标向后查找关键字 #或者g#2、光标向前查找关键字 *或者g*3、当前行查找字符 fx, Fx, tx, Tx4、基本替换 :s/s1/s2 （将下一个s1替换为s2）5、全部替换 :%s/s1/s26、只替换当前行 :s/s1/s2/g7、替换某些行 :n1,n2 s/s1/s2/g8、搜索模式为 /string，搜索下一处为n，搜索上一处为N9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母10、移动到某标签处 `x，1旁边的键11、移动到上次编辑文件的位置 `.PS：.代表一个任意字符 *代表一个或多个字符的重复 正则表达式的内容将会在后续文章中整理三、编辑操作1、光标后插入a, 行尾插入A2、后插一行插入o，前插一行插入O3、删除字符插入s， 删除正行插入S4、光标前插入i，行首插入I5、删除一行dd，删除后进入插入模式cc或者S6、删除一个单词dw，删除一个单词进入插入模式cw7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl8、粘贴p，交换两个字符xp，交换两行ddp9、复制y，复制一行yy10、撤销u，重做ctrl + r，重复.11、智能提示 ctrl + n 或者 ctrl + p12、删除motion跨过的字符，删除并进入插入模式 c&#123;motion&#125;13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx15、删除motion跨过的字符，删除但不进入插入模式 d&#123;motion&#125;16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx18、如果只是复制的情况时，将12-17条中的c或d改为y19、删除到行尾可以使用D或C20、拷贝当前行 yy或者Y21、删除当前字符 x22、粘贴 p23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy24、重复执行上一个作用使用.25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进27、 &gt;&gt; 缩进所有选择的代码28、 &lt;&lt; 反缩进所有选择的代码29、gd 移动到光标所处的函数或变量的定义处30、K 在man里搜索光标所在的词31、合并两行 J32、若不想保存文件，而重新打开 :e!33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换四、窗口操作1、分隔一个窗口:split或者:vsplit2、创建一个窗口:new或者:vnew3、在新窗口打开文件:sf &#123;filename&#125;4、关闭当前窗口:close5、仅保留当前窗口:only6、到左边窗口 ctrl + w, h7、到右边窗口 ctrl + w, l8、到上边窗口 ctrl + w, k9、到下边窗口 ctrl + w, j10、到顶部窗口 ctrl + w, t11、到底部窗口 ctrl + w, b五、宏操作1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中2、@[a-z]执行寄存器[a-z]中的操作3、@@执行最近一次记录的宏操作六、可视操作1、进入块可视模式 ctrl + v2、进入字符可视模式 v3、进入行可视模式 V4、删除选定的块 d5、删除选定的块然后进入插入模式 c6、在选中的块同是插入相同的字符 I&lt;String&gt;ESC七、跳到声明1、[[ 向前跳到顶格第一个&#123; 2、[] 向前跳到顶格第一个&#125;3、]] 向后跳到顶格的第一个&#123;4、]] 向后跳到顶格的第一个&#125;5、[&#123; 跳到本代码块的开头6、]&#125; 跳到本代码块的结尾八、挂起操作1、挂起Vim ctrl + z 或者 :suspend2、查看任务 在shell中输入 jobs3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）4、执行shell命令 :!command5、开启shell命令 :shell，退出该shell exit6、保存vim状态 :mksession name.vim7、恢复vim状态 :source name.vim8、启动vim时恢复状态 vim -S name.vim]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux无损调整分区大小]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FLinux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[场景500G 硬盘 100MB `boot`分区 |8G `swap`分区 |450G `/`分区 我需要将/home分区单独提取一个分区出来，即变成 100MB `boot`分区 |8G `swap`分区 |100G `/`分区 |350G `/home`分区 步骤 sudo e2fsck -fy /dev/sda3 // f 是表示检查，y表示一直确认，直到修复完 sudo resize2fs /dev/sda3 100G //将文件系统调整到50G（不太明白文件系统大小和分区大小的关系） sudo fdisk /dev/sda // 使用fdisk进行分区 首先输入p，查看要调整分区（sda3）的start序号（重要） 输入 d 删除要sda3，选择3 输入 n 添加一个主分区，分区号选择3 选择start地址，就是刚才查看的地址（一般不用修改，默认就是刚才的值） 选择分区容量，输入+100G 然后再新建一个分区，输入n，选择p（主分区），选择默认起点，再选择默认终点 按w保存分区表 这里有可能会报错，什么device被占用之类的错误 使用 partprobe /dev/sda命令重载/dev/sda 重载分区表，（命令成功界面没有显示） sudo e2fsck -fy /dev/sda3 修复sda3分区 sudo resize2fs /dev/sda3 检查一下有没有问题 sda3分区已经没有问题了，数据全部都保留着。 格式化sda4 sudo mkfs.ext4 /dev/sda4 然后就是迁移所有/home数据到sda4 在fstab中添加一行 UUID=xxxxxxxxxxxxxxx /home ext4 defaults 0 0 开机后使用sudo chown -R username:username /home/fan，否则由于权限问题导致无法登录 大功告成！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux创建开机启动服务]]></title>
    <url>%2F2019%2F03%2F03%2Fyuque%2FLinux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[需求使用linux离不开ss，每次都需要手动输入命令开启，很麻烦，所以需要创建开机就启动的服务。 前提假设我们有一段需要开机启动的服务脚本/home/username/document/ss-local.sh如下 ss-local -c /home/username/document/ssconfig.json 创建服务（两种方式） 1. 创建成系统服务然后在/etc/init.d/新建ss-local文件，注意这个文件的写法 #!/bin/sh### BEGIN INIT INFO# Provides: ss-local // 名字要和文件名一样# Required-Start: $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5 # Default-Stop: 0 1 6# Short-Description: local shadowsocks service### END INIT INFOset -ePATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin. /lib/lsb/init-functionsNAME=ss-localDEAMON=/home/username/document/ss-local.sh # 注意设置正确的脚本路径start_sslocal() &#123; start-stop-daemon --start --background --name $NAME --exec $DEAMON&#125;stop_sslocal() &#123; start-stop-daemon --stop --name $NAME&#125;case "$1" in start|"") start_sslocal ;; restart|reload|force-reload) stop_sslocal ;; stop) exit 0 ;; *) esac 将文件的权限置为755 sudo chmod 755 ss-local 将服务文件设置为开机启动 sudo update-rc.d ss-local defaults 启动服务 sudo systemctl start ss-local 2. 创建成systemd服务定位到/usr/lib/systemd/system目录（如果没有就新建），新建ss-local.service。 [Unit]#定义描述Description=The ss-local service#指定了在systemd在执行完那些target之后再启动该服务After=network.target remote-fs.target nss-lookup.target[Service]#定义Service 的运行type，一般是forking，就是后台运行Type=simple#以下定义systemctl start |stop |reload *.service 的每个执行方法，具体命令#需要&gt;写绝对路径ExecStart=/home/fan/Documents/ss/ss-local.sh#创建私有的内存临时空间PrivateTmp=true[Install]WantedBy=multi-user.target 然后就可以设置开机启动了 # 开机启动sudo systemctl enable ss-local.service# 启动服务sudo systemctl start ss-local.service 完]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript变态题]]></title>
    <url>%2F2018%2F03%2F22%2Fyuque%2Fjavascript%E5%8F%98%E6%80%81%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原帖： https://github.com/xiaoyu2er/blog/issues/1原题来自: javascript-puzzlers 读者可以先去做一下感受感受. 当初笔者的成绩是 21/44… 当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了…. 不过, 对于基础知识的理解是深入编程的前提. 让我们一起来看看这些变态题到底变态不变态吧! 第1题[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 知识点: Array/map Number/parseInt Global_Objects/parseInt JavaScript parseInt 首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值 其中回调函数接受三个参数 currentValue, index, arrary; 而题目中, map只传入了回调函数–parseInt. 其次, parseInt 只接受两个两个参数 string, radix(基数). 在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理： 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。如果字符串 string 以其它任何值开头，则基数是10 (十进制)。所以本题即问 parseInt(&apos;1&apos;, 0);parseInt(&apos;2&apos;, 1);parseInt(&apos;3&apos;, 2); 首先后两者参数不合法. 所以答案是 [1, NaN, NaN] 第2题[typeof null, null instanceof Object] 两个知识点: Operators/typeof Operators/instanceof Operators/instanceof(中) typeof 返回一个表示类型的字符串. instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上. 这个题可以直接看链接… 因为 typeof null === ‘object’ 自语言之初就是这样…. typeof 的结果请看下表: type result Undefined “undefined” Null “object” Boolean “boolean” Number “number” String “string” Symbol “symbol” Host object Implementation-dependent Function “function” Object “object” 所以答案 [object, false] 第3题[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] 知识点: Array/Reduce arr.reduce(callback[, initialValue]) reduce接受两个参数, 一个回调, 一个初始值. 回调函数接受四个参数 previousValue, currentValue, currentIndex, array 需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown. 所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9 答案 an error 第4题var val = &apos;smtg&apos;;console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;); 两个知识点: Operators/Operator_Precedence Operators/Conditional_Operator 简而言之 + 的优先级 大于 ? 所以原题等价于 ‘Value is true’ ? ‘Somthing’ : ‘Nonthing’ 而不是 ‘Value is’ + (true ? ‘Something’ : ‘Nonthing’) 答案 ‘Something’ 第5题var name = &apos;World!&apos;;(function () &#123; if (typeof name === &apos;undefined&apos;) &#123; var name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)(); 这个相对简单, 一个知识点: Hoisting在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。 这个题目相当于 var name = &apos;World!&apos;;(function () &#123; var name; if (typeof name === &apos;undefined&apos;) &#123; name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)(); 所以答案是 ‘Goodbye Jack’ 第6题var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); 一个知识点: Infinity在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停. js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。 第7题var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;); 答案是 [] 看一篇文章理解稀疏数组 译 JavaScript中的稀疏数组与密集数组Array/filter我们来看一下 Array.prototype.filter 的 polyfill: if (!Array.prototype.filter) &#123; Array.prototype.filter = function(fun/*, thisArg*/) &#123; &apos;use strict&apos;; if (this === void 0 || this === null) &#123; throw new TypeError(); &#125; var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== &apos;function&apos;) &#123; throw new TypeError(); &#125; var res = []; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t) &#123; // 注意这里!!! var val = t[i]; if (fun.call(thisArg, val, i, t)) &#123; res.push(val); &#125; &#125; &#125; return res; &#125;;&#125; 我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下. 0 in ary; =&gt; true3 in ary; =&gt; false10 in ary; =&gt; true也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的. 第8题var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two] JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3IEEE 754标准中的浮点数并不能精确地表达小数 那什么时候精准, 什么时候不经准呢? 笔者也不知道… 答案 [true, false] 第9题function showCase(value) &#123; switch(value) &#123; case &apos;A&apos;: console.log(&apos;Case A&apos;); break; case &apos;B&apos;: console.log(&apos;Case B&apos;); break; case undefined: console.log(&apos;undefined&apos;); break; default: console.log(&apos;Do not know!&apos;); &#125;&#125;showCase(new String(&apos;A&apos;)); 两个知识点: Statements/switch String switch 是严格比较, String 实例和 字符串不一样. var s_prim = &apos;foo&apos;;var s_obj = new String(s_prim);console.log(typeof s_prim); // &quot;string&quot;console.log(typeof s_obj); // &quot;object&quot;console.log(s_prim === s_obj); // false 答案是 ‘Do not know!’ 第10题function showCase2(value) &#123; switch(value) &#123; case &apos;A&apos;: console.log(&apos;Case A&apos;); break; case &apos;B&apos;: console.log(&apos;Case B&apos;); break; case undefined: console.log(&apos;undefined&apos;); break; default: console.log(&apos;Do not know!&apos;); &#125;&#125;showCase2(String(&apos;A&apos;)); 解释:String(x) does not create an object but does return a string, i.e. typeof String(1) === “string” 还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦. 答案 ‘Case A’ 第11题function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, &apos;13&apos;, -9, Infinity];values.map(isSane); 一个知识点 Arithmetic_Operators#Remainder此题等价于 7 % 2 =&gt; 14 % 2 =&gt; 0‘13’ % 2 =&gt; 1-9 % % 2 =&gt; -1Infinity % 2 =&gt; NaN需要注意的是 余数的正负号随第一个操作数. 答案 [true, true, true, false, false] 第12题parseInt(3, 8)parseInt(3, 2)parseInt(3, 0) 第一个题讲过了, 答案 3, NaN, 3 第13题Array.isArray( Array.prototype )一个知识点: Array/prototype一个鲜为人知的实事: Array.prototype =&gt; []; 答案: true 第14题var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log(&quot;wut&quot;);&#125; JavaScript-Equality-Table更新通过一张简单的图，让你彻底地、永久地搞懂JS的==运算 非常不错的一篇文章!解析: Boolean([0]) === true[0] == truetrue 转换为数字 =&gt; 1[0] 转化为数字失败, 转化为字符串 ‘0’, 转化成数字 =&gt; 00 !== 1答案: false 第15题[]==[] [] 是Object, 两个 Object 不相等 答案是 false 第16题&apos;5&apos; + 3&apos;5&apos; - 3 两个知识点: Arithmetic_Operators#Addition Arithmetic_Operators#Subtraction 用来表示两个数的和或者字符串拼接, -表示两数之差. 请看例子, 体会区别: &gt; &apos;5&apos; + 3&apos;53&apos;&gt; 5 + &apos;3&apos;&apos;53&apos;&gt; 5 - &apos;3&apos;2&gt; &apos;5&apos; - 32&gt; &apos;5&apos; - &apos;3&apos;2 也就是说 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接. 答案是 ‘53’, 2 第17题1 + - + + + - + 1 这里应该是(倒着看) 1 + (a) =&gt; 2a = - (b) =&gt; 1b = + (c) =&gt; -1c = + (d) =&gt; -1d = + (e) =&gt; -1e = + (f) =&gt; -1f = - (g) =&gt; -1g = + 1 =&gt; 1 所以答案 2 第18题var ary = Array(3);ary[0]=2ary.map(function(elem) &#123; return &apos;1&apos;; &#125;); 稀疏数组. 同第7题. 题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’. 所以答案是 [“1”, undefined × 2] 这里贴上 Array.prototype.map 的 polyfill. Array.prototype.map = function(callback, thisArg) &#123; var T, A, k; if (this == null) &#123; throw new TypeError(&apos; this is null or not defined&apos;); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== &apos;function&apos;) &#123; throw new TypeError(callback + &apos; is not a function&apos;); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; A = new Array(len); k = 0; while (k &lt; len) &#123; var kValue, mappedValue; if (k in O) &#123; kValue = O[k]; mappedValue = callback.call(T, kValue, k, O); A[k] = mappedValue; &#125; k++; &#125; return A; &#125;; 第19题function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) 这是一个大坑, 尤其是涉及到 ES6语法的时候 知识点: Functions/arguments首先 The arguments object is an Array-like object corresponding to the arguments passed to a function. 也就是说 arguments 是一个 object, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改. 所以答案是 21. 然而!!!!!! 当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了….. 请看: function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c=3) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) 答案是 12 !!!! 请读者细细体会!! 第20题var a = 111111111111111110000, b = 1111;a + b; 答案还是 111111111111111110000. 解释是 Lack of precision for numbers in JavaScript affects both small and big numbers. 但是笔者不是很明白……………. 请读者赐教! 第21题var x = [].reverse;x(); 这个题有意思! 知识点: Array/reverse The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array. 也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 window. 补充: stellar91 这个笔者实践了一下 发现 firefox 是 window, chrome 报错 VM190:2 Uncaught TypeError: Array.prototype.reverse called on null or undefined(…) 可能是实现不同, 在 chrome 中应该是对调用者做了检查. 答案是 window 第22题Number.MIN_VALUE &gt; 0 true 第23题[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1] 这个题也还可以. 这个题会让人误以为是 2 &gt; 1 &amp;&amp; 2 &lt; 3 其实不是的. 这个题等价于 1 &lt; 2 =&gt; true;true &lt; 3 =&gt; 1 &lt; 3 =&gt; true;3 &lt; 2 =&gt; false;false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;答案是 [true, true] 第24题// the most classic wtf 2 == [[[2]]] 这个题我是猜的. 我猜的 true, 至于为什么….. both objects get converted to strings and in both cases the resulting string is “2” 我不能信服… 第25题3.toString()3..toString()3...toString() 这个题也挺逗, 我做对了 答案是 error, ‘3’, error 你如果换一个写法就更费解了 var a = 3;a.toString() 这个答案就是 ‘3’; 为啥呢? 因为在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法啊! 第26题(function()&#123; var x = y = 1;&#125;)();console.log(y);console.log(x); 答案是 1, error y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 ReferenceError 第27题var a = /123/, b = /123/;a == ba === b 即使正则的字面量一致, 他们也不相等. 答案 false, false 第28题var a = [1, 2, 3], b = [1, 2, 3], c = [1, 2, 4]a == ba === ba &gt; ca &lt; c 字面量相等的数组也不相等. 数组在比较大小的时候按照字典序比较 答案 false, false, false, true 第29题var a = &#123;&#125;, b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) === b] 知识点: Object/getPrototypeOf只有 Function 拥有一个 prototype 的属性. 所以 a.prototype 为 undefined. 而 Object.getPrototypeOf(obj) 返回一个具体对象的原型(该对象的内部[[prototype]]值) 答案 false, true 第30题function f() &#123;&#125;var a = f.prototype, b = Object.getPrototypeOf(f);a === bf.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy. f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型. 请看: a === Object.getPrototypeOf(new f()) // trueb === Function.prototype // true 答案 false 第31题function foo() &#123; &#125;var oldName = foo.name;foo.name = &quot;bar&quot;;[oldName, foo.name] 答案 [‘foo’, ‘foo’] 知识点: Function/name因为函数的名字不可变. 第32题&quot;1 2 3&quot;.replace(/\d/g, parseInt) 知识点: String/replace#Specifying_a_function_as_a_parameterstr.replace(regexp|substr, newSubStr|function) 如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数 match 首先是匹配的字符串p1, p2 …. 然后是正则的分组offset match 匹配的indexstring 整个字符串由于题目中的正则没有分组, 所以等价于问 parseInt(&apos;1&apos;, 0)parseInt(&apos;2&apos;, 2)parseInt(&apos;3&apos;, 4) 答案: 1, NaN, 3 第33题function f() &#123;&#125;var parent = Object.getPrototypeOf(f);f.name // ?parent.name // ?typeof eval(f.name) // ?typeof eval(parent.name) // ? 先说以下答案 ‘f’, ‘Empty’, ‘function’, error 这个答案并不重要….. 这里第一小问和第三小问很简单不解释了. 第二小问笔者在自己的浏览器测试的时候是 ‘’, 第四问是 ‘undefined’ 所以应该是平台相关的. 这里明白 parent === Function.prototype 就好了. 第34题var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()] 知识点: RegExp/test这里 test 函数会将参数转为字符串. ‘nul’, ‘undefined’ 自然都是全小写了 答案: true, true 第35题[,,,].join(&quot;, &quot;)[,,,] =&gt; [undefined × 3] 因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦) 答案: “, , “ 第36题var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;a.class 这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了) 所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’] 第37题var a = new Date(&quot;epoch&quot;) 知识点: Date Date/parse 简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件. 另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 Invalid Date. 答案 Invalid Date 第38题var a = Function.length, b = new Function().lengtha === b 我们知道一个function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0. 另外 Function.length 定义为1…… 所以不相等…….答案 false 第39题var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c] 还是关于Date 的题, 需要注意的是 如果不传参数等价于当前时间.如果是函数调用 返回一个字符串.答案 false, false, false 第40题var min = Math.min(), max = Math.max()min &lt; max 知识点: Math/minMath/max有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity 答案: false 第41题function captureOne(re, str) &#123; var match = re.exec(str); return match &amp;&amp; match[1];&#125;var numRe = /num=(\d+)/ig, wordRe = /word=(\w+)/i, a1 = captureOne(numRe, &quot;num=1&quot;), a2 = captureOne(wordRe, &quot;word=1&quot;), a3 = captureOne(numRe, &quot;NUM=2&quot;), a4 = captureOne(wordRe, &quot;WORD=2&quot;);[a1 === a2, a3 === a4] 知识点: RegExp/exec通俗的讲 因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会 举个例子 var myRe = /ab*/g;var str = &apos;abbcdefabh&apos;;var myArray;while ((myArray = myRe.exec(str)) !== null) &#123; var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;; msg += &apos;Next match starts at &apos; + myRe.lastIndex; console.log(msg);&#125;// Found abb. Next match starts at 3// Found ab. Next match starts at 9 所以 a1 = ‘1’; a2 = ‘1’; a3 = null; a4 = ‘2’ 答案 [true, false] 第42题var a = new Date(&quot;2014-03-19&quot;), b = new Date(2014, 03, 19);[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()] 这个…. JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object. a.getDay()3b.getDay()6a.getMonth()2b.getMonth()3 都是套路! 答案 [false, false] 第43题if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123; &apos;a gif file&apos;&#125; else &#123; &apos;not a gif file&apos;&#125; 知识点: String/matchString.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义那么 /gif 就匹配了 /.gif/ 答案: ‘a gif file’ 第44题function foo(a) &#123; var a; return a;&#125;function bar(a) &#123; var a = &apos;bye&apos;; return a;&#125;[foo(&apos;hello&apos;), bar(&apos;hello&apos;)] 在两个函数里, a作为参数其实已经声明了, 所以 var a; var a = ‘bye’ 其实就是 a; a =’bye’ 所以答案 ‘hello’, ‘bye’ 全部结束! 总结由于笔者水平有限, 如果解释有误, 还望指出 通过整理, 笔者发现绝大部分题目都是因为自己对于基础知识或者说某个 API 的参数理解偏差才做错的. 笔者的重灾区在原型那一块, 所以这次被虐和整理还是很有意义呀. 笔者相信 坚实的基础是深入编程的前提. 所以基础书还是要常看啊 最后这些变态题现在看看还变态嘛?]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猜数字游戏算法]]></title>
    <url>%2F2018%2F03%2F16%2Fyuque%2F%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目有猜数字游戏如下 庄家预先写下一个四位数字（每位数字各不相同），玩家每次随机猜一个数字，庄家告知玩家猜对了几A几B（A代表数字和位置都相同，B代表包含该数字但位置不同，比如如果庄家写的是3514，玩家猜的是3165，庄家会回答1A2B），玩家继续猜，直到猜中为止。如果超过5轮没猜中，则玩家输，否则玩家赢。请为玩家设计一个猜数字的算法，确保玩家能够大概率胜。例如：庄家写下9876，玩家第一次猜0123，庄家回复0A0B；玩家继续猜4567，庄家恢复0A2B；依次下去，知道玩家猜中9876为止。 一道很有意思的题目，网上搜索下，发现有很多解法，主流两种 筛选法 信息熵法 筛选法筛选法原理很简单，首先我们需要知道庄家所有可能结果的集合 10*9*8*7 === 5040 // 总共有5040个可能结果 然后，玩家猜一个数字，和庄家数字对比后得到一个反馈结果某A某B 这时候，我们把所有5040个可能的结果和玩家数字对比，再从中过滤出和某A某B一样反馈的结果集，那么这个结果集中一定包含了庄家数字，这就是一次过滤，排除很多无关的数据。 然后在第一次过滤出来的结果集中随机取一个数字，用这个数字和庄家对比进行第二次猜测，用上面的方法在上一次的过滤结果中再次过滤，得到第二次过滤结果。 循环过滤，最后只剩一个结果。 算法代码首先是得到所有可能数字的集合，本质上是0-9999之间每位不重复的数字集合。 let data = [] // 集合数据for (let i = 0; i &lt; 9999; i++) &#123; let str if (i &lt;= 999) &#123; str = '0' + i // 例子： 0987 这种特殊情况 &#125; else &#123; str = '' + i &#125; const arr = str.split('') if (new Set(arr).size !== 4) continue // 判断size === 4，表示没有重复数字 data.push(arr)&#125;console.log(data) // [...] 两串数字对比并得到反馈的函数 function analyse(basicArr, compareArr) &#123; let count = 0 basicArr.forEach((value, index) =&gt; &#123; if (value == compareArr[index]) &#123; count++ &#125; &#125;) const A = count const B = (compareArr.length + basicArr.length) - new Set([...basicArr, ...compareArr]).size - A return `A$&#123;A&#125;B$&#123;B&#125;`&#125;console.log( analyse([1,2,3,4], [0,2,4,7]) // A1B1) 过滤函数那部分就简单了，略。 整体代码如下，大概率在第五次过滤就只有一个结果存在了，少部分在5次前就出来了，部分需要更多次过滤。 // 这个函数用于分析两个数组之间的反馈function analyse(basicArr, compareArr) &#123; let count = 0 basicArr.forEach((value, index) =&gt; &#123; if (value == compareArr[index]) &#123; count++ &#125; &#125;) const A = count const B = (compareArr.length + basicArr.length) - new Set([...basicArr, ...compareArr]).size - A return `A$&#123;A&#125;B$&#123;B&#125;`&#125;// 默认以结果集第一个数据为猜测值, 最后根据猜测反馈的值过滤出所有符合反馈的数据function filter(preResult) &#123; const guess = preResult[0] const re = analyse(store, guess) const filterResult = preResult.filter(arr =&gt; &#123; if (analyse(guess, arr) == re) &#123; return true &#125; &#125;) return filterResult&#125;// 开始let data = []// 以下for循环用来将符合猜规则的数据存放到data变量for (let i = 0; i &lt; 9999; i++) &#123; let str if (i &lt;= 999) &#123; str = '0' + i &#125; else &#123; str = '' + i &#125; const arr = str.split('') if (new Set(arr).size !== 4) continue data.push(arr)&#125;// 随机生成庄家数组const store = data[Math.ceil(Math.random() * data.length) - 1]console.log('庄家数据: ', store)// 以下每一次filter包含一次猜测,返回可能的结果集,在结果集中重复过滤,大概率会在第五次猜测后得到唯一的数据, 第六次概率更高const filterResult1 = filter(data)const filterResult2 = filter(filterResult1)const filterResult3 = filter(filterResult2)const filterResult4 = filter(filterResult3)const filterResult5 = filter(filterResult4)console.log(filterResult5) 信息熵法待以后有空补充]]></content>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于原型链]]></title>
    <url>%2F2018%2F03%2F14%2Fyuque%2F%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[以下这张图，基本解释了所有的原型关系 核心要素是： var Foo = function ()&#123;&#125;var foo = new Foo()foo.__proto__ == foo.constructor.prototype == Foo.prototype// .__proto__ 可以简单理解成 .construstor.prototype 的简写 但本质上__proto__不等于.constructor.prototype，当我把对象的constructor置为null，.__proto__还是能够读到，但是.constructor.prototype直接报错了。这里这么说只是为了方便理解说到底.__proto__就是这个对象的构造函数的原型。 理解了这个就能理解上面图示的所有的关系了。 以下有助于理解几个基类之间的关系instanceof操作符 instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的： //设 L instanceof R //通过判断 L.__proto__.__proto__ ..... === R.prototype ？ //最终返回true or false 也就是沿着L的__proto__一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了 Function instanceof Object // true Object instanceof Function // true Function instanceof Function //true Object instanceof Object // true Number instanceof Number //false 总结了下Object.constructor === function Function ()&#123;&#125; // trueFunction.constructor === function Function ()&#123;&#125; // true// 两个需要特殊注意一下， 记住这个基本上能把所有的东西都推理出来了。Function.prototype === functoin ()&#123; native code &#125; // true Function.prototype.constructor === Funtion // trueFunction.prototype.constructor.prototype === function ()&#123; native code &#125; // true// ...无限循环Function.prototype.__proto__ === Object.prototype // trueObject.prototype.__proto__ === null // 原型链的终点 关于__proto____proto__ 是内部的构造函数原型对象， 一般情况下 obj.__proto__ === obj.constructor.prototype // true 但是__proto__不会因为你在对象的prototype中更改constructor而改变。它总是指向对象被创建时的那个constructor function ， 举个例子： function Animal()&#123;&#125;function Dog()&#123;&#125;Dog.prototype = new Animal();Dog.prototype.constructor = Dog; // 在继承的时候，这里改变了prototype.constructor，但是不影响__proto__的结果// 完成继承new Dog() instanceof Animal // truenew Dog() instanceof Dog // true// 根据以上 instanceof 的原理new Dog().__proto__.__proto__ === Animal.prototype // true// 在这里__proto__和constructor.prototype的结果就不同, 一定要搞清楚new Dog().__proto__.constructor.prototype === Animal.prototype // falsenew Dog().__proto__.constructor.prototype === Dog.prototype // true 部分内容摘自作者：苏墨橘链接：https://www.zhihu.com/question/34183746/answer/59043879]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
