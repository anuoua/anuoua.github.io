<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>microk8s kubelet自动补全</title>
      <link href="/2021/07/17/microk8s%20kubelet%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/"/>
      <url>/2021/07/17/microk8s%20kubelet%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>原生kubectl，在.bashrc中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure><p>microk8s自带的kubectl，需要先设置别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias kubectl=microk8s.kubectl</span><br><span class="line">source &lt;(microk8s.kubectl completion bash)</span><br></pre></td></tr></table></figure><a id="more"></a><p>完</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Certbot自动续签SSL证书</title>
      <link href="/2021/02/22/Certbot%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BESSL%E8%AF%81%E4%B9%A6/"/>
      <url>/2021/02/22/Certbot%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BESSL%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>https已经必不可少，经常部署vps手动申请部署证书很麻烦，证书会过期，需要定期更新，没这个精力，现在我们可以利用certbot自动申请ssl证书，非常方便。</p><p>certbot有很多种方式申请证书，具体可查看文档：<a href="https://certbot.eff.org/docs/" target="_blank" rel="noopener">https://certbot.eff.org/docs/</a>，不同方式的用途不一样，如果只是静态网站，那么可以选择nginx插件部署，如果是科学上网，那么建议使用webroot更方便。</p><a id="more"></a><h2 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h2><p>系统：ubuntu 20.04</p><p>域名DNS解析到这台机器的IP</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>不管是部署静态网站还是科学上网，都要安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y nginx</span><br></pre></td></tr></table></figure><p>安装certbot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y certbot</span><br></pre></td></tr></table></figure><h3 id="nginx插件方式"><a href="#nginx插件方式" class="headerlink" title="nginx插件方式"></a>nginx插件方式</h3><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y python3-certbot-nginx  # 官网写的是 python-certbot*，但是在ubuntu 20.04上已经更新为python3了</span><br></pre></td></tr></table></figure><p>运行以下命令，按照提示输入正确信息即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>还原操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx rollback</span><br></pre></td></tr></table></figure><p>可以访问https域名进行测试。</p><h3 id="webroot方式"><a href="#webroot方式" class="headerlink" title="webroot方式"></a>webroot方式</h3><p>webroot方式依赖现成的静态服务（nginx），它需要在指定的目录下生成特殊的文件，用于验证。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --webroot -w /var/www/html -d www.example.com</span><br><span class="line"><span class="meta">#</span> -d 指定申请的域名，可以写多个</span><br><span class="line"><span class="meta">#</span> -w 指定静态服务的根目录，在nginx中默认是/var/www/html</span><br></pre></td></tr></table></figure><p>可以到/etc/letsencrypt/live/中查看已经申请到的证书</p><p>两个证书key: privkey.pem，cert: fullchain.pem，可以用在nginx和科学上网，自行配置即可。</p><h3 id="自动续签"><a href="#自动续签" class="headerlink" title="自动续签"></a>自动续签</h3><p>certbot的更新证书命令，这个命令会自动判断是否需要更新，如果没有满足条件，会跳过更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --cert-name xxx.xxx.com --post-hook "systemctl restart nginx &amp;&amp; systemctl restart ..."</span><br></pre></td></tr></table></figure><p>这个命令带有两个hook，可以做一些特殊的操作，比如重启nginx或者重启科学上网服务。</p><p>如果要做到自动续签，就要借助crontab，这个工具是linux用来运行定时任务的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e # 选择vim编辑定时任务，一行一个定时任务。</span><br></pre></td></tr></table></figure><p>它的格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 */7 * * certbot renew --cert-name xxx.xxx.com --post-hook "systemctl restart nginx &amp;&amp; systemctl restart ..."</span><br></pre></td></tr></table></figure><p>上面命令表示每隔7天凌晨3点执行证书更新操作，如果需要其他更新周期的话，可以查看crontab文档。</p><p>这样就能实现自动续签ssl证书，永久使用，除非letsencrypt完蛋。</p><h3 id="撤销证书"><a href="#撤销证书" class="headerlink" title="撤销证书"></a>撤销证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot revoke --cert-path /etc/letsencrypt/live/CERTNAME/cert.pem</span><br></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Observable 和 Subject 的区别</title>
      <link href="/2020/11/04/Observable%20%E5%92%8C%20Subject%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/04/Observable%20%E5%92%8C%20Subject%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>根据rxjs官网的说法，Observable是冷数据流，Subject是热数据流。</p><p>我的理解，从数据生成角度</p><ul><li>Observable： 数据生成者，数据产生在内部</li><li>Subject：数据生成者和消费者，可以从外部接收数据</li></ul><p>举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable, Subject &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe$ = Observable.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">observe$.subscribe(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(a) &#125;) <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line">subject.subscribe(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(a) &#125;) <span class="comment">// 1, 2</span></span><br><span class="line">subject.next(<span class="number">1</span>)</span><br><span class="line">subject.next(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>从数据实时性角度</p><ul><li>Observable：所有订阅，都可以获取到完全（任意时间，包含订阅前产生的）的数据流（冷）。</li><li>Subject：只能获取到订阅后产生的数据流，即实时数据（热）。</li></ul><p>举个例子（还是上面那个，改），能说明问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable, Subject &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe$ = Observable.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  observe$.subscribe(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(a) &#125;) <span class="comment">// 一秒后订阅仍然输出 1, 2</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line">subject.next(<span class="number">1</span>)</span><br><span class="line">subject.next(<span class="number">2</span>)</span><br><span class="line">subject.subscribe(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(a) &#125;) <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure><p>这两者合理的组合用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使两个观察者 observer1 和 observer2 “共享” tick$，</span></span><br><span class="line"><span class="comment">// 我们可以通过 Subject 来传输所有通知，像这样</span></span><br><span class="line"><span class="keyword">const</span> tick$ = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line">subject.subscribe(observer1);</span><br><span class="line">subject.subscribe(observer2);</span><br><span class="line">tick$.subscribe(subject);</span><br></pre></td></tr></table></figure><p>完</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识docker</title>
      <link href="/2020/08/01/%E5%88%9D%E8%AF%86docker/"/>
      <url>/2020/08/01/%E5%88%9D%E8%AF%86docker/</url>
      
        <content type="html"><![CDATA[<h1 id="初识docker"><a href="#初识docker" class="headerlink" title="初识docker"></a>初识docker</h1><p>docker这么火，必须要了解一下了。</p><p>之前在别的部门接了个前端项目，做了个需求，是后台打印pdf文件，导出。找了很多方案，决定使用puppeteer无头chrome作为后端打印机用。本地开发没什么问题，但是到了线上问题就大了，在线编译无法通过，编译环境是centos环境，无法下载chrome，chrome的依赖也没有。做了很多额外的恶心的东西在里面。这时候，想到如果开发环境和部署环境一样的话，多好，完全没有这种问题。而docker就可以解决这些问题。</p><a id="more"></a><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>由于国内网络的原因，docker-desktop 下载地址从阿里云开源镜像获取<code>https://mirrors.aliyun.com/docker-ce/win/stable/Docker%20Desktop%20Installer.exe</code>。</p><p>奇怪的是直接从外部访问<code>https://mirrors.aliyun.com/docker-ce/win</code>看不到<code>stable</code>目录。。</p><p>还是由于国内网络原因，docker-hub上的镜像拉取也很慢，可以使用以下镜像进行加速</p><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th><th><a href>专属加速器？</a></th><th><a href>其它加速？</a></th></tr></thead><tbody><tr><td><a href="https://docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 中国官方镜像</a></td><td><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></td><td></td><td>Docker Hub</td></tr><tr><td><a href="https://daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud 镜像站</a></td><td><a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a></td><td>可登录，系统分配</td><td>Docker Hub</td></tr><tr><td><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像</a></td><td><a href="https://dockerhub.azk8s.cn" target="_blank" rel="noopener">https://dockerhub.azk8s.cn</a></td><td></td><td>Docker Hub、GCR、Quay</td></tr><tr><td><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大镜像站</a></td><td><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></td><td></td><td>Docker Hub、GCR、Quay</td></tr><tr><td><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云</a></td><td>https://<your_code>.mirror.aliyuncs.com</your_code></td><td>需登录，系统分配</td><td>Docker Hub</td></tr><tr><td><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云</a></td><td><a href="https://reg-mirror.qiniu.com" target="_blank" rel="noopener">https://reg-mirror.qiniu.com</a></td><td></td><td>Docker Hub、GCR、Quay</td></tr><tr><td><a href="https://c.163yun.com/hub" target="_blank" rel="noopener">网易云</a></td><td><a href="https://hub-mirror.c.163.com" target="_blank" rel="noopener">https://hub-mirror.c.163.com</a></td><td></td><td>Docker Hub</td></tr><tr><td><a href="https://cloud.tencent.com/document/product/457/9113" target="_blank" rel="noopener">腾讯云</a></td><td><a href="https://mirror.ccs.tencentyun.com" target="_blank" rel="noopener">https://mirror.ccs.tencentyun.com</a></td><td></td><td>Docker Hub</td></tr></tbody></table><p>配置方式：windows打开docker-desktop配置页，Docker Engine选项</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://xxxx.xxx.xxxx.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [],</span><br><span class="line">  <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"experimental"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linux则是打开（没有就创建）<code>/etc/docker/daemon.json</code>，编辑并重启<code>systemctl restart docker</code></p><h2 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h2><p>首先拉取一个镜像，如果拉取很慢或者失败，请按照上面的国内源配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><p>然后跑一下这个镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hello from Docker!</span></span><br><span class="line"><span class="comment"># This message shows that your installation appears to be working correctly.</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>以上是一个最简单的容器应用。试试运行一个大型容器看看，gitlab的容器应用，gitlab如果自己部署的话实在太麻烦了，它要求安装几个数据库，系统的依赖等一系列前置要求，然后还要编译，再运行，实属不便。但是有了docker就方便多了。</p><p>先拉取gitlab-ce(gitlab-ce是社区版的意思)的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce[:TAG]  <span class="comment"># TAG 如果不手动填写那么默认为last</span></span><br></pre></td></tr></table></figure><p>慢慢等，大概有2G，国内镜像的话还是比较快的，然后直接运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"><span class="comment"># i：--interactive 打开交互式命令行</span></span><br><span class="line"><span class="comment"># t：--tty 分配一个Tty终端</span></span><br><span class="line"><span class="comment"># d：--detach 后台运行</span></span><br><span class="line">    -itd</span><br><span class="line">    <span class="comment"># 端口映射 格式一般为 -p [宿主机端口]:[容器内部端口] 可以写多组。</span></span><br><span class="line">    <span class="comment"># 要保证宿主机的端口没有被占用，否则启动失败。</span></span><br><span class="line">    -p 8443:443 -p 8880:80 -p 2222:22 \</span><br><span class="line">    <span class="comment"># 容器名称，方便后续操作</span></span><br><span class="line">    --name gitlab \</span><br><span class="line">    <span class="comment"># 这个表示映射目录，将容器内的目录挂载到外面（一些资源文件夹，比如配置，静态资源，日志）方便修改和查看。这里先不用。</span></span><br><span class="line">    <span class="comment"># --volume /u1/gitlab/config:/etc/gitlab \</span></span><br><span class="line">    <span class="comment"># --volume /u1/gitlab/logs:/var/log/gitlab \</span></span><br><span class="line">    <span class="comment"># --volume /u1/gitlab/data:/var/opt/gitlab \</span></span><br><span class="line">    gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p>访问<code>localhost:8880</code>就能看到gitlab，部署非常快捷，这就是docker要解决的痛点：由于运行环境差异导致的产品部署困难。</p><p>有了docker，运行环境的差异被抹平了。同样的一个镜像，无论再哪个物理机器上运行，环境都是一致的。</p><h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><p>docker命令主要分为对镜像的操作和对容器的操作，以下通过操作ubuntu，实现从拉取镜像到最后删除镜像的一整套操作。</p><p>先拉取一个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像的格式为 IMAGE_NAME:TAG，比如ubuntu就有很多个镜像比如：ubuntu:18.04</span></span><br><span class="line">docker pull ubuntu:20.04</span><br></pre></td></tr></table></figure><p>然后创建一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># i：--interactive 打开交互式命令行</span></span><br><span class="line"><span class="comment"># t：--tty 分配一个Tty终端</span></span><br><span class="line">docker create -it --name DOCKER_NAME ubuntu:20.04</span><br></pre></td></tr></table></figure><p>接着运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># i：--interactive 打开交互式命令行</span></span><br><span class="line"><span class="comment"># a：--attach 附着到Tty终端，不传这个参数，它就在后台运行。</span></span><br><span class="line">docker start -ai CONTAINER_NAME</span><br></pre></td></tr></table></figure><p>发现进入了ubuntu的root用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start -ai ubuntu:20.04</span><br><span class="line">root@e5cbbc1fe725:/#</span><br></pre></td></tr></table></figure><p>嗯，现在可以运行linux命令了。</p><p><code>docker create</code> 和 <code>docker start</code> 可以合并起来， 等于<code>docker run</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=CONTAINER_NAME ubuntu:20.04</span><br></pre></td></tr></table></figure><p>查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">// 或者</span><br><span class="line">docker container list -a</span><br></pre></td></tr></table></figure><p>根据容器状态处理下一步，比如要停止容器后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop CONTAINER_NAME_OR_ID</span><br></pre></td></tr></table></figure><p>停止后删除容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm CONTAINER_NAME_OR_ID</span><br></pre></td></tr></table></figure><p>最后删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE_NAME:TAG</span><br></pre></td></tr></table></figure><p>主要就是两大类，操作容器和操作镜像，具体操作可以看<a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker教程</a>。</p><h3 id="如何理解容器"><a href="#如何理解容器" class="headerlink" title="如何理解容器"></a>如何理解容器</h3><p>启动一个容器就是启动一个进程（进程内部新建的进程也可以认为是一个容器，只不过不可见）。</p><p>把docker run 一个容器理解成运行一条命令，镜像内部已经把很多命令封装好了，暴露在外部的参数，给用户自定义。</p><p>所以一条命令可以前端运行，也可以后台运行，docker run 附加参数就可以做到。</p><p>容器大概不能像普通操作系统一样使用，比如就算镜像集成了openssh，咱们docker run容器后台运行，是无法从外部ssh连接的，它运行的只是（拿ubuntu举例）<code>/bin/bash</code>这个入口命令，而openssh的服务进程并没有启动，只能进入容器手动启动openssh服务。也可以手动更改入口命令，让openssh随着入口命令一起启动，这样就能在docker run后直接通过ssh连接。</p><p>总而言之：一个容器就是一个进程。不能简单当作系统来理解，毕竟docker要的是轻量，如果做的和真实系统一样，一开始启动一大堆服务的话，轻量的特性就不存在了。</p><h2 id="镜像的构建"><a href="#镜像的构建" class="headerlink" title="镜像的构建"></a>镜像的构建</h2><p>docker的镜像构建方式主要有两种，容器构建，dockerfile构建</p><h3 id="通过容器构建"><a href="#通过容器构建" class="headerlink" title="通过容器构建"></a>通过容器构建</h3><p>创建容器后，在内部进行了很多运行环境的配置工作，配置完成后想要把这个容器作为镜像，方便后续使用。</p><p>镜像的制作很像git操作，修改了很多文件，git status就会显示改了哪里，docker也差不多，运行以下命令查看容器进行了哪些改动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff CONTAINER_NAME_OR_ID</span><br></pre></td></tr></table></figure><p>和git一样，改好的代码需要git commit，docker也一样有commit命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br><span class="line"></span><br><span class="line">docker commit \</span><br><span class="line">    --author <span class="string">"YOUNAME &lt;xxxxx@hikvision.com&gt;"</span> \</span><br><span class="line">    --message <span class="string">"修改很多东西"</span> \</span><br><span class="line">    CONTAINER_NAME_OR_ID \</span><br><span class="line">    IMAGE_NAME:TAG</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><p>一个新的镜像就诞生了，如果觉得ok，直接上传到dockerhub，共享给别人使用。</p><h3 id="通过dockerfile构建"><a href="#通过dockerfile构建" class="headerlink" title="通过dockerfile构建"></a>通过dockerfile构建</h3><p>上面的例子，已经可以制作镜像了，但是这里产生了一个问题。</p><p>容器配置了很多东西在里面，但是这个镜像基本不能一摸一样重复的制作出来，除非很简单。要是这个镜像丢了就完蛋了，因为整个构建过程不可见，不可重复。</p><p>所以有了dockerfile，用于描述每一步构建过程，可重复，可修改，易共享。</p><p>来看一个样本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:20.04 <span class="comment"># 源镜像</span></span><br><span class="line"></span><br><span class="line">MAINTAINER  xxxx xxxx@hikvision.com.cn <span class="comment"># 作者信息</span></span><br><span class="line"></span><br><span class="line">COPY ./download/* /root/download/ <span class="comment"># 复制文件到镜像</span></span><br><span class="line"></span><br><span class="line">COPY ./scripts/* /root/scripts/</span><br><span class="line"></span><br><span class="line">SHELL [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>] <span class="comment"># 指定运行dockerfile RUN命令的shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 docker run 的时候运行</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="comment"># 等于</span></span><br><span class="line">CMD [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入口命令和CMD差不多，但是这个可以动态加参数</span></span><br><span class="line">ENTRYPOINT [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ] <span class="comment"># docker run myip -i 就会带上 -i 参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建详情</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'start build'</span> &amp;&amp; \</span><br><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">cat /root/download/sources.list &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Asia/Shanghai'</span> &gt; /etc/timezone &amp;&amp; \</span><br><span class="line"><span class="comment"># 更新安装依赖</span></span><br><span class="line">apt update &amp;&amp; \</span><br><span class="line">apt install -y git wget tree openssh-server &amp;&amp; \</span><br><span class="line"><span class="comment"># 清理工作</span></span><br><span class="line">apt remove wget -y &amp;&amp; \</span><br><span class="line">apt auto-remove -y &amp;&amp; \</span><br><span class="line">apt clean &amp;&amp; \</span><br><span class="line">rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">rm -rf /tmp/*</span><br></pre></td></tr></table></figure><p>dockerfile 中很常见的几个命令<code>FROM</code>，<code>MAINTAINER</code>，<code>COPY</code>，<code>SHELL</code>，<code>RUN</code>。</p><p>前三个好理解，SHELL命令为啥指定shell，这里是有原因的。</p><p>dockerfile默认的SHELL是 [“/bin/sh”, “-c”]，sh没有source命令，会导致后续无法应用.bashrc中配置的环境变量。</p><p>RUN命令就是构建脚本，可以写多个，上面每一步都可以拆成单个RUN命令，但是RUN命令每运行一次就会commit一次，运行越多，commit越多，最后导致镜像文件很大。</p><p>如果写到单个RUN命令里面，只commit一次，借助RUN尾部的清理命令，一次commit下来增加的体积就会小很多。</p><p>在dockerfile目录中运行 <code>docker build -t IMAGE_NAME:TAG .</code>后面那个点不能省略，表示构建目录为此目录。</p><p>新镜像诞生。</p><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>在到处都是分布式系统的年代，一套系统拥有N个服务，也就是会有N个容器，那么如何管理容器就成了十分紧迫的需求，比如给容器分配cpu，内存，端口等等。所以需要一个容器资源管理系统来处理这些问题。</p><p>容器管理平台的基本特征：</p><ul><li>调度</li><li>资源管理</li><li>服务发现</li><li>健康检查</li><li>自动伸缩</li><li>更新和升级</li></ul><p>所以业界有了Kubernetes（k8s），Docker Swarm，Apache Mesos等容器编排平台，k8s显然成为了领导者，这里不深入了。</p><h2 id="docker基本原理"><a href="#docker基本原理" class="headerlink" title="docker基本原理"></a>docker基本原理</h2><p>vmware之类的虚拟机可以进行硬件级别的虚拟，很强大，但是太重量级了，资源消耗很大，吃cpu，吃内存，启动慢。</p><p>docker利用了一种新的思路，假设虚拟的系统和宿主系统用的一样的内核，只要共享这个系统内核就没有必要再模拟硬件的输入输出这种重量级的工作了。甚至可以在共享内核的基础上，创建各类进程，来虚拟完整系统功能。我们把这种操作系统级别的轻量化虚拟机，叫做<strong>容器</strong>。</p><p>容器共享的是宿主机器的内核，要做到接近硬件虚拟机的效果，就要将文件系统，进程系统，内存系统，等等一系列东西和宿主机器进行隔离。最大限度的接近虚拟机。</p><p>这也解释了为什么windows版docker要依赖hyperv启动，原因就是上面说的容器需要共享宿主内核，而宿主平台是windows，不能给linux容器共享内核，所以docker启动必须依赖hyperv，docker启动时会在hyperv中启动一个真实的虚拟机，利用这个linux的虚拟机的内核，做共享内核，在这个基础上运行容器。</p><p>同时也解释了容器是进程这个概念，和我们理解的操作系统不一样。</p><h2 id="docker分层文件系统"><a href="#docker分层文件系统" class="headerlink" title="docker分层文件系统"></a>docker分层文件系统</h2><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层文件系统示意图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------+</span><br><span class="line">|   current layer                  | &lt;- 当前层</span><br><span class="line">|------------------------------+   |</span><br><span class="line">|   commit3 (read only)        |   |</span><br><span class="line">|--------------------------+   |   |</span><br><span class="line">|   commit2  (read only)   |   |   |</span><br><span class="line">|----------------------+   |   |   |</span><br><span class="line">|   commit1 (read only)|   |   |   |</span><br><span class="line">|                      |   |   |   |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></table></figure><p>镜像包含了四层文件系统，底下三层都是只读的，只有当前层可以读写。</p><p>可以发现分层文件系统有点类似git代码库，除非代码回退，否则之前构建的数据永远存在。docker构建层级越深镜像体积越大，git代码库也是一样，commit越多仓库体积越大，代码全删了也没用。</p><p>所以构建docker镜像层级不能太深，尽量选择原生的docker镜像做定制，一层搞定是最好的，否则docker镜像体积会明显增大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>docker大大降低了运维的难度，创造性的容器应用充满了无限的想象力，未来大型应用的容器化是绝对的趋势，拥抱未来！</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>koa-compose原理</title>
      <link href="/2020/07/16/koa-compose%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/16/koa-compose%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近看了看koa的源码，源码很简洁，组织的很清爽。</p><p>这里面最重要的一块是中间件的实现，koa通过<code>koa-compose</code>串联到了一起。</p><p>koa-compose的设计目标： 每个中间件中的逻辑按照洋葱圈的方式执行。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(PORT);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上述代码的执行顺序，按照如下的箭头方向依次执行，每一个圈都是一个中间件，每个中间件，都可以选择前置或者后置执行对应逻辑，这就是洋葱模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     +---------------------------------+</span><br><span class="line">     |                                 |</span><br><span class="line">     |                                 |</span><br><span class="line">     |#1: 1                      #1: 1 |</span><br><span class="line">     |      +-------------------+      |</span><br><span class="line">     |      |                   |      |</span><br><span class="line">     |      |#2: 2         #2: 2|      |</span><br><span class="line">     |      |     +-------+     |      |</span><br><span class="line">     |      |     | #3: 3 |     |      |</span><br><span class="line">     |      |     |       |     |      |</span><br><span class="line">+-------------------------------------------&gt;</span><br><span class="line">     |      |     |       |     |      |</span><br><span class="line">     |      |     +-------+     |      |</span><br><span class="line">     |      |                   |      |</span><br><span class="line">     |      +-------------------+      |</span><br><span class="line">     |                                 |</span><br><span class="line">     |                                 |</span><br><span class="line">     +---------------------------------+</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是注册中间件，它通过use方法，将中间件放入app实例中的middleware数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(fn);</span><br></pre></td></tr></table></figure><p>接下来就是执行中间件，来看其中一部分源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  callback() &#123;</span><br><span class="line">    <span class="comment">// 组合中间件</span></span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="comment">// 当请求过来的时候，交由handleRequest处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="comment">// 在这里将ctx传入中间件组合函数，运行所有中间件后，交由handleResponse处理</span></span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>中间件在callback中经过compose处理返回了一个promise函数，然后在handleRequest函数中执行处理所有的中间件，最终返回结果交由handleResponse处理。</p><p>那么compose到底做了什么？</p><p>来看compose源码，很精简。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 判断当前中间件是否运行了多次</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="comment">// 获取当前中间件函数</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="comment">// compose函数支持扩展中间件，通过next，在最后插入其他中间件。</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里执行中间件，并将下一个中间件的dispatch函数绑定后传入，由其控制。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 中间件运行报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compose会返回一个触发（dispatch）函数，每一次运行dispatch，就会执行一个middleware，同时它记录了一个middleware的执行座标<code>i</code>，通过<code>i</code>来获取middleware数组中当前执行的中间件函数，同时也根据这个座标巧妙的判断当前中间件是否执行了多次。</p><p>比较重要的是，下一个中间件dispatch函数会被绑定后传入当前执行的中间件函数，把下一个中间件dispatch函数控制权交给了当前中间件内的逻辑，以此实现了前置和后置执行的洋葱模型。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>reflect-metadata原理</title>
      <link href="/2020/07/09/reflect-metadata%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/09/reflect-metadata%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看依赖注入控制反转，javascript的实现借助了inversifyjs，而inversifyjs又用到了reflect-medadata，简单的研究了下reflect-metadata内部结构，想看看它是怎么存储元数据的。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>简单看一个api</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br></pre></td></tr></table></figure><a id="more"></a><p>它内部定义了一个weakmap，用于和target关联，创建这个weakmap的主要流程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> metadata = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">metadata.set(metadataKey, metadataValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> metadataMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">metadataMap.set(propertyKey, metadata)</span><br><span class="line"></span><br><span class="line">weakmap.set(target, metadataMap)</span><br></pre></td></tr></table></figure><p>分为三层map，每一个target通过weakmap映射到一个metadataMap，metadataMap内部存储了target对象上所有键的元数据（metadata），metadata也是一个map，里面映射metadataKey =&gt; metadataValue，大致如此。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s单机部署</title>
      <link href="/2020/07/01/k8s%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/07/01/k8s%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需要一个方便部署应用的平台，搜索了以后选择主流的k8s。</p><p>k8s有很多安装方式，原生官方网站的安装方式很麻烦，组件众多，大多需要科学上网。于是开始寻找一种方便的安装方式，而且需要支持单机部署（master和worker节点在一个机器上），找到几个靠谱的方案。</p><ul><li><p><strong>minikube</strong>：它的好处是安装足够方便，指定docker国内镜像即可一路绿灯，安装完成。但是缺点是基本只能单机学习用，其master是安装在docker中的，对外发布的时候，不能像原生安装那样，设定一个port就能让集群外的人访问，只能本机访问，要对外发布的话，就有很大的成本，比较适合个人学习使用。</p></li><li><p><strong>microk8s&amp;k3s</strong>：这两个都是轻量级的k8s方案，安装较方便，内置了很多常用的插件和服务。但是同样的会遇到很多问题，不少问题都是他们自己封装的时候特有的，不方便排查。同时这两个都强制使用containerd作为驱动，作为容器标准化的产物，containerd相比少了一层交互，但是命令行完全没有docker用的舒服，同时令人费解的toml配置，很令人劝退。</p></li><li><p><strong>部署工具安装</strong>：这是最终使用的方案，kubeadm部署工具，因为microk8s和k3s也无法摆脱科学上网，同时还增加了更多的问题。那为什么不使用官网的方式安装呢？事实证明按照官网安装是坑最少的，官网中文教程非常详细，而且有各种国内源加速，问题解决方法容易搜索到。</p></li></ul><a id="more"></a><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>官网：<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">部署工具安装</a></p><p>官网教程非常详细，以下步骤中的几点需要注意：</p><h3 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h3><p>这部分最后一项</p><blockquote><p>禁用交换分区。为了保证 kubelet 正常工作，您 必须 禁用交换分区。</p></blockquote><p>编辑<code>/etc/fstab</code>文件，在swap那行前面加#号注释掉，操作完最好重启。</p><h3 id="确保每个节点上-MAC-地址和-product-uuid-的唯一性"><a href="#确保每个节点上-MAC-地址和-product-uuid-的唯一性" class="headerlink" title="确保每个节点上 MAC 地址和 product_uuid 的唯一性"></a>确保每个节点上 MAC 地址和 product_uuid 的唯一性</h3><p>一般无问题</p><h3 id="检查网络适配器"><a href="#检查网络适配器" class="headerlink" title="检查网络适配器"></a>检查网络适配器</h3><p>一般无问题</p><h3 id="确保-iptables-工具不使用-nftables-后端"><a href="#确保-iptables-工具不使用-nftables-后端" class="headerlink" title="确保 iptables 工具不使用 nftables 后端"></a>确保 iptables 工具不使用 nftables 后端</h3><p>一般无问题</p><h3 id="检查所需端口"><a href="#检查所需端口" class="headerlink" title="检查所需端口"></a>检查所需端口</h3><p>如果有端口占用的，需要kill掉进程。一般新机器部署的话，都是正常的。</p><h3 id="安装-runtime"><a href="#安装-runtime" class="headerlink" title="安装 runtime"></a>安装 runtime</h3><p>如果机器已经安装了docker，那么也必须看”CRI 安装指南”这个连接里面的内容。</p><p>安装docker-ce使用国内云厂商的镜像可以快速安装。</p><p>配置docker的daemon.json文件非常重要，否则会导致后面kubelet服务挂掉。</p><h3 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h3><p>这几个工具国内云厂商有镜像可以直接用，可以去开源镜像站搜索kubernetes镜像，如果不行就换一个，有的厂商可能更新不及时。同时不要忘记这个步骤中设置的参数。</p><h3 id="在控制平面节点上配置-kubelet-使用的-cgroup-驱动程序"><a href="#在控制平面节点上配置-kubelet-使用的-cgroup-驱动程序" class="headerlink" title="在控制平面节点上配置 kubelet 使用的 cgroup 驱动程序"></a>在控制平面节点上配置 kubelet 使用的 cgroup 驱动程序</h3><p>使用docker的话可以跳过。马上尝试kubeadm部署。</p><h3 id="运行kubeadm"><a href="#运行kubeadm" class="headerlink" title="运行kubeadm"></a>运行kubeadm</h3><p>先不要运行kubeadm init，因为直接运行等了很久会报错，显示无法pull一些docker镜像。这些镜像来自<code>k8s.gcr.io</code>，我们用阿里云的镜像地址<code>registry.aliyuncs.com/google_containers</code>。</p><p>首先列出kubeadm需要的镜像列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如这些</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/kube-apiserver:v1.19.4</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/kube-controller-manager:v1.19.4</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/kube-scheduler:v1.19.4</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/kube-proxy:v1.19.4</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/pause:3.2</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/etcd:3.4.13-0</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/coredns:1.7.0</span></span><br></pre></td></tr></table></figure><p>然后把<code>k8s.gcr.io</code>替换成<code>registry.aliyuncs.com/google_containers</code>后统统pull到本地，接着通过docker tag命令一个一个再改成原来的名字，即<code>k8s.gcr.io/xxx:xxx</code>这样的形式。这样就可以直接跳过kubeadm自己下载镜像的过程了。同理，后面遇到的镜像问题也可以用同样的方式解决，先下载好国内镜像，然后改名。docker拉取镜像走代理的话，<a href="#docker代理问题">#docker代理问题</a></p><p>这里需要我们预先启用kubelet服务<code>systemctl enable kubelet</code>。</p><p>然后就可以运行kubeadm init了，不出意外的话，可以直接走到底完成安装。完成安装后注意显示出来的信息，这里面会包含一些设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>按照提示操作，然后运行一下<code>kubectl get pods --all-namespaces</code>命令，看看是否大部分都启动了（running状态），除了dns相关的pod，应该都跑起来了，意味着kubeadm init成功。</p><p>dns相关的pod需要网络插件安装后才能启动。</p><p>那么如果中途失败了怎么办，很简单，运行kubeadm reset，手动删除<code>$HOME/.kube/</code>文件夹（重要，reset后会提示你删除），然后重启机器，按照流程重新来一遍，直到完全成功。</p><h2 id="安装网络插件flannel"><a href="#安装网络插件flannel" class="headerlink" title="安装网络插件flannel"></a>安装网络插件flannel</h2><p><a href="https://github.com/coreos/flannel" target="_blank" rel="noopener">flannel</a>可以直接这样安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>网络不行无法直接访问的话，先浏览器访问<code>https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code>复制文本内容到本地，然后运行<code>kubectl apply -f kube-flannel.yml</code>安装。</p><p>利用<code>kubectl get pods --all-namespaces</code>查看pod状态，发现flannel的pod起不来。需要修改<code>/etc/kubernetes/manifests/kube-controller-manager.yaml</code>，在command中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--allocate-node-cidrs=<span class="literal">true</span></span><br><span class="line">--cluster-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>重启kubelet</p><p>然后重新部署flannel，过一会儿flannel起来，再查看<code>kubectl get pods --all-namespaces</code>，发现所有的pod都起来了。</p><h2 id="安装kubernetes-dashboard"><a href="#安装kubernetes-dashboard" class="headerlink" title="安装kubernetes-dashboard"></a>安装kubernetes-dashboard</h2><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">kubenetes-dashboard</a>和上面差不多的安装方式，不多讲了。</p><p>安装完之后，利用default命名空间下的default账户的token访问网页会有问题，默认的default用户是没有权限查看整个集群的状态的。需要添加权限。</p><p>创建default-clusteradmin.yaml。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bind-default-to-cluster-admin</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure><p>部署<code>kubectl apply -f default-clusteradmin.yaml</code>。</p><h3 id="单节点，设置master节点也可以运行Pod"><a href="#单节点，设置master节点也可以运行Pod" class="headerlink" title="单节点，设置master节点也可以运行Pod"></a>单节点，设置master节点也可以运行Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><p>至此，全部完成。</p><h2 id="docker代理问题"><a href="#docker代理问题" class="headerlink" title="docker代理问题"></a>docker代理问题</h2><p>docker如何走代理拉镜像？首先docker是不会走系统代理信息的，也就是在环境变量中设置http(s)_proxy是无效的，需要按照以下步骤操作。</p><ol><li>创建systemd内的文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><ol start="2"><li>用以下的格式，创建一个文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=https://proxy.example.com:443"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>重启docker服务，即可应用代理。</li></ol><h2 id="k8s的镜像"><a href="#k8s的镜像" class="headerlink" title="k8s的镜像"></a>k8s的镜像</h2><ul><li>k8s.gcr.io: registry.aliyuncs.com/google_containers</li><li>gcr.io: registry.aliyuncs.com/google_containers</li><li>dockerhub: 去阿里云注册一个。</li><li>quray.io（安装flannel要用）：国内可以直接访问。</li></ul><p>gcr.io/k8s.gcr.io 这两是兄弟。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter的坑</title>
      <link href="/2020/06/08/Flutter%E7%9A%84%E5%9D%91/"/>
      <url>/2020/06/08/Flutter%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Flutter国内镜像"><a href="#Flutter国内镜像" class="headerlink" title="Flutter国内镜像"></a>Flutter国内镜像</h2><p>国内下载flutter和安装依赖实在是太太太太太慢了！！！</p><p>下面是国内几个镜像，PUB_HOSTED_URL是Dart依赖包地址，FLUTTER_STORAGE_BASE_URL是Flutter依赖文件地址。</p><p>要手动下载最新版本的flutter SDK包，可以访问 FLUTTER_STORAGE_BASE_URL 地址，然后进入/flutter_infra/releases/目录下载（这个方式Flutter社区不可用）。</p><a id="more"></a><p>Flutter 社区<br>社区主镜像，采用多种方式同步 Flutter 开发者资源（推荐）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>上海交大 Linux 用户组<br>使用反向代理方式建立的 Flutter 镜像，数据与站源实时同步。 Pub API 返回值未做处理，可能造成无法访问的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn</span><br></pre></td></tr></table></figure><p>清华大学 TUNA 协会<br>定时与 Flutter 社区 Storage 镜像同步，Pub API 采取定时主动抓取策略，镜像配置了完善的失败回源策略（推荐）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter</span><br></pre></td></tr></table></figure><p>CNNIC<br>基于 TUNA 协会的镜像服务，数据策略与 TUNA 一致，通过非教育网的域名访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=http://mirrors.cnnic.cn/dart-pub</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=http://mirrors.cnnic.cn/flutter</span><br></pre></td></tr></table></figure><p>腾讯云开源镜像站<br>定时（每天凌晨）与 TUNA 协会镜像同步，数据有延迟，访问速度有待反馈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PUB_HOSTED_URL=https://mirrors.cloud.tencent.com/dart-pub</span><br><span class="line">$ <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.cloud.tencent.com/flutter</span><br></pre></td></tr></table></figure><h2 id="开发或者编译卡死的问题"><a href="#开发或者编译卡死的问题" class="headerlink" title="开发或者编译卡死的问题"></a>开发或者编译卡死的问题</h2><p>开发或者编译会遇到 <code>Running Gradle task &#39;assembleDebug&#39;...</code> 或者 <code>Running Gradle task &#39;assembleRelease&#39;...</code> 。</p><p>因为需要下载安卓中的一些依赖，maven，下载地址需要替换。</p><p>打开 <code>flutter_app/android/build.gradle</code>，修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.3.50'</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        // google()</span><br><span class="line">        // jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;  </span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // google()</span><br><span class="line">        // jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;  </span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开flutter的SDK目录<code>flutter/packages/flutter_tools/gradle/flutter.gradle</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // google()</span><br><span class="line">        // jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;   </span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.5.0'</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">// 下面这个变量改成国内地址</span><br><span class="line">private static final String MAVEN_REPO      = <span class="string">"https://storage.flutter-io.cn/download.flutter.io"</span>;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 如果还有问题，那么可以排查安装的依赖包，有的依赖包也需要gradle编译，所以也要修改repositories，可以在import语句那里ctrl加鼠标点击跳转到依赖包目录，进行同样的操作即可修复。</p><p>如果flutter run 失败了，或者ctrl+c，请在任务管理器中把dart，java相关的进程kill掉，再重试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redsocks搭配iptables实现真全局代理</title>
      <link href="/2020/05/28/redsocks%E6%90%AD%E9%85%8Diptables%E5%AE%9E%E7%8E%B0%E7%9C%9F%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
      <url>/2020/05/28/redsocks%E6%90%AD%E9%85%8Diptables%E5%AE%9E%E7%8E%B0%E7%9C%9F%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="安装redsocks"><a href="#安装redsocks" class="headerlink" title="安装redsocks"></a>安装redsocks</h2><p>代码库<a href="https://github.com/darkk/redsocks" target="_blank" rel="noopener">redsocks</a>，直接clone到本地。</p><p>前置条件：安装libevent和build-essential。</p><p>进入clone的目录，直接输入make命令编译，只要不是错误，警告消息可以忽略。在目录下会出现一个redsocks的可执行文件。</p><h2 id="redsocks配置"><a href="#redsocks配置" class="headerlink" title="redsocks配置"></a>redsocks配置</h2><p>在目录下新建一个配置文件<code>redsocks.conf</code>，目录下有个叫<code>redsocks.conf.example</code>的全量配置文件，复制它的内容到<code>redsocks.conf</code>，然后修改之，以下把很多注释的东西删除了，改动的地方已标明。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">base &#123;</span><br><span class="line">log_debug = off;</span><br><span class="line">log_info = on;</span><br><span class="line">daemon = off;</span><br><span class="line">redirector = iptables;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redsocks &#123;</span><br><span class="line">local_ip = 127.0.0.1;</span><br><span class="line">local_port = 12345; &lt;= 这端口试tcp监听端口</span><br><span class="line"></span><br><span class="line">ip = 127.0.0.1;  &lt;= socks5 服务地址 </span><br><span class="line">port = 1081;  &lt;= socks5 服务端口</span><br><span class="line"></span><br><span class="line">type = socks5; &lt;= 一般都是 socks5 （ss, tro..）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redudp &#123;</span><br><span class="line">local_ip = 127.0.0.1;</span><br><span class="line">local_port = 10053; &lt;= 这端口试udp监听端口</span><br><span class="line"></span><br><span class="line">ip = 127.0.0.1; &lt;= socks5 服务地址</span><br><span class="line">port = 1081; &lt;= socks5 服务端口</span><br><span class="line"></span><br><span class="line">// login = username;  &lt;= 无需登录信息，删除</span><br><span class="line">// password = pazzw0rd; &lt;= 同上</span><br><span class="line"></span><br><span class="line">dest_ip = 8.8.8.8;</span><br><span class="line">dest_port = 53;</span><br><span class="line"></span><br><span class="line">udp_timeout = 30;</span><br><span class="line">udp_timeout_stream = 180;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dnstc &#123;</span><br><span class="line">local_ip = 127.0.0.1;</span><br><span class="line">local_port = 5300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dnsu2t &#123;</span><br><span class="line">local_ip = 127.0.0.1;</span><br><span class="line">local_port = 5313;</span><br><span class="line"></span><br><span class="line">remote_ip = 8.8.8.8;</span><br><span class="line">remote_port = 53;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动redsocks"><a href="#启动redsocks" class="headerlink" title="启动redsocks"></a>启动redsocks</h2><p>输入<code>./redsocks</code>运行，默认读取目录下的<code>redsocks.conf</code>，也可后台启动，自行配置。</p><h2 id="iptables配置"><a href="#iptables配置" class="headerlink" title="iptables配置"></a>iptables配置</h2><p>启动防火墙<code>sudo ufw enable</code>，新建以下防火墙脚本，运行后即可全局上，建议先<code>iptables-save &gt; /etc/iptables.rules</code>保存修改前的防火墙，用完后可恢复<code>iptables-restore /etc/iptables.rules</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create new chain</span></span><br><span class="line">iptables -t nat -N REDSOCKS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下xxx.xxx.xxx.xxx是你的远程代理服务器ip，防止循环</span></span><br><span class="line">iptables -t nat -A REDSOCKS -d xxx.xxx.xxx.xxx -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 127.0.0.1 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 100.64.0.0/10 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 198.18.0.0/15 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line"></span><br><span class="line"><span class="comment"># Anything else should be redirected to port 12345</span></span><br><span class="line">iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br><span class="line"><span class="comment"># 以下是udp的转发，端口是上述配置文件中的 redudp-&gt;local_port</span></span><br><span class="line"><span class="comment"># 如果开启udp，那么以下的tcp转发规则需要多一份针对udp的，改一下-p参数即可，未测试。</span></span><br><span class="line"><span class="comment"># iptables -t nat -A REDSOCKS -p udp -j REDIRECT --to-ports 10053</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br><span class="line">iptables -t nat -A PREROUTING --<span class="keyword">in</span>-interface enp3s0 -p tcp -j REDSOCKS  <span class="comment"># 注意修改网卡enp3s0名称</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭yarn升级检查.md</title>
      <link href="/2020/05/22/%E5%85%B3%E9%97%ADyarn%E5%8D%87%E7%BA%A7%E6%A3%80%E6%9F%A5/"/>
      <url>/2020/05/22/%E5%85%B3%E9%97%ADyarn%E5%8D%87%E7%BA%A7%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>在内网环境安装yarn使用的时候，出现yarn一直没有响应的情况。</p><p>原因是yarn安装完成会做升级检查，内网环境无法访问外网请求。</p><p>只需要关闭yarn自升级检查即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br><span class="line">yarn config <span class="built_in">set</span> <span class="built_in">disable</span>-self-update-check <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git搭配.gitattributes强制项目文本使用lf作为换行符</title>
      <link href="/2020/05/21/Git%E6%90%AD%E9%85%8D.gitattributes%E5%BC%BA%E5%88%B6%E9%A1%B9%E7%9B%AE%E6%96%87%E6%9C%AC%E4%BD%BF%E7%94%A8lf%E4%BD%9C%E4%B8%BA%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
      <url>/2020/05/21/Git%E6%90%AD%E9%85%8D.gitattributes%E5%BC%BA%E5%88%B6%E9%A1%B9%E7%9B%AE%E6%96%87%E6%9C%AC%E4%BD%BF%E7%94%A8lf%E4%BD%9C%E4%B8%BA%E6%8D%A2%E8%A1%8C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>在windows上开发的时候，文件换行符默认是<code>crlf</code>，在编写dockerfile的时候，复制到linux上的文件需要保持<code>lf</code>换行符，才能保证运行不会出问题。</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>如果只要自己本地生效，那么输入一下命令，重新提交或者clone即可，但是别人还是会出问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><p>如果想要所有人都使用<code>lf</code>作为换行符，别人在windows上git clone的时候，保持<code>lf</code>换行符，就需要借助<code>.gitattributes</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  text=auto eol=lf</span><br></pre></td></tr></table></figure><p>将文件放在项目根目录，然后运行<code>git rm --cached -r .</code> 和<code>git reset --hard</code>，将替换所有文件的换行符。</p><p>更多<code>.gitattributes</code>文件的配置，可以看这个库<a href="https://github.com/alexkaratarakis/gitattributes" target="_blank" rel="noopener">gitattributes</a></p><p>再搭配<code>.editorconfig</code>配置IDE，新建/编辑文件默认转成就是<code>lf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">end_of_line = lf</span><br><span class="line">insert_final_newline = <span class="literal">true</span>  <span class="comment">#默认插入最后一行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shield tv 8.0 系统替换默认桌面</title>
      <link href="/2020/05/04/shield%20tv%208.0%20%E7%B3%BB%E7%BB%9F%E6%9B%BF%E6%8D%A2%E9%BB%98%E8%AE%A4%E6%A1%8C%E9%9D%A2/"/>
      <url>/2020/05/04/shield%20tv%208.0%20%E7%B3%BB%E7%BB%9F%E6%9B%BF%E6%8D%A2%E9%BB%98%E8%AE%A4%E6%A1%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>先安装launcher，atvlauncher或者HAlauncher（HALauncher，需要勾选作为默认桌面的项），不安装会导致后续无法进入桌面。</p><p>首先开启盒子的adb调试，打开设置》设备偏好设置》关于》内部版本号，多按几次确认键，打开开发者模式。</p><p>然后打开设置》设备偏好设置》开发者选项》网络调试（或者USB调试）。</p><a id="more"></a><p>然后就是在电脑上使用adb命令禁用默认桌面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb connect xxx.xxx.xxx.xxx //  网络调试下，连接到电视机的ip地址</span><br><span class="line">adb shell</span><br><span class="line">pm disable-user --user0 com.google.android.tvlauncher  // 要恢复就把前面改成 enable-user</span><br></pre></td></tr></table></figure><p>然后就可以点击home按键试试了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shield tv 无法访问互联网的解决办法</title>
      <link href="/2020/04/26/shield%20tv%20%E5%B7%B2%E8%BF%9E%E6%8E%A5%20%E4%BD%86%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2020/04/26/shield%20tv%20%E5%B7%B2%E8%BF%9E%E6%8E%A5%20%E4%BD%86%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这个问题一般有两个原因，也分两种情况，一种是可以上网，一种是无法上网，我们可以利用adb工具进行设置，设置之前请打开网络调试。</p><h2 id="可以上网"><a href="#可以上网" class="headerlink" title="可以上网"></a>可以上网</h2><p>这种情况下只需要通过如下方法去掉提示即可，原因是wifi检测是否可以访问网络，需要访问国外网址，这个地址国内不通，我们替换成国内网址就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb connect xxx.xxx.xxx.xxx</span><br><span class="line">adb shell settings put global captive_portal_detection_enabled 1</span><br><span class="line">adb shell settings put global captive_portal_mode 1</span><br><span class="line">adb shell settings put global captive_portal_use_https 0</span><br><span class="line">adb shell settings put global captive_portal_server connect.rom.miui.com</span><br><span class="line">adb shell settings put global captive_portal_http_url http://connect.rom.miui.com/generate_204</span><br><span class="line">adb shell settings put global captive_portal_https_url https://connect.rom.miui.com/generate_204</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="不能上网"><a href="#不能上网" class="headerlink" title="不能上网"></a>不能上网</h2><p>这种情况下，可能是系统时间和网络时间对不上导致的，可以尝试手动调整系统时间，或者通过以下adb命令行设置时间服务器为国内即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global ntp_server ntp1.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在shell中嵌入多行文本（配置文件）</title>
      <link href="/2020/03/21/%E5%A6%82%E4%BD%95%E5%9C%A8shell%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89/"/>
      <url>/2020/03/21/%E5%A6%82%E4%BD%95%E5%9C%A8shell%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/23929235/multi-line-string-with-extra-space-preserved-indentation" target="_blank" rel="noopener">stackoverflow 链接</a></p><h2 id="answer"><a href="#answer" class="headerlink" title="answer"></a>answer</h2><p>Heredoc sounds more convenient for this purpose. It is used to send multiple commands to a command interpreter program like ex or cat</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EndOfMessage</span><br><span class="line">This is line 1.</span><br><span class="line">This is line 2.</span><br><span class="line">Line 3.</span><br><span class="line">EndOfMessage</span><br></pre></td></tr></table></figure><p>The string after &lt;&lt; indicates where to stop.</p><p>To send these lines to a file, use:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; $FILE &lt;&lt;- EOM</span><br><span class="line">Line 1.</span><br><span class="line">Line 2.</span><br><span class="line">EOM</span><br></pre></td></tr></table></figure><p>You could also store these lines to a variable:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read -r -d '' VAR &lt;&lt; EOM</span><br><span class="line">This is line 1.</span><br><span class="line">This is line 2.</span><br><span class="line">Line 3.</span><br><span class="line">EOM</span><br></pre></td></tr></table></figure><p>This stores the lines to the variable named VAR.</p><p>When printing, remember the quotes around the variable otherwise you won’t see the newline characters.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "$VAR"</span><br></pre></td></tr></table></figure><p>Even better, you can use indentation to make it stand out more in your code. This time just add a - after &lt;&lt; to stop the tabs from appearing.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read -r -d '' VAR &lt;&lt;- EOM</span><br><span class="line">    This is line 1.</span><br><span class="line">    This is line 2.</span><br><span class="line">    Line 3.</span><br><span class="line">EOM</span><br></pre></td></tr></table></figure><p>But then you must use tabs, not spaces, for indentation in your code.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode远程开发的代理配置</title>
      <link href="/2020/02/28/vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/02/28/vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>去年vscode就支持了远程开发，通过ssh连接到服务器，就像在本地写代码一样，实在是太爽了。</p><p>但是有一个问题是，vscode的ssh无法通过代理访问，官方文档上的方法需要一台<code>跳板机</code>来完成。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jump box with public IP address</span></span><br><span class="line">Host jump-box</span><br><span class="line">    HostName 52.179.157.97</span><br><span class="line">    User sana</span><br><span class="line">    IdentityFile ~/.ssh/jumpbox</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target machine with private IP address</span></span><br><span class="line">Host target-box</span><br><span class="line">    HostName &lt;IP address of target&gt;</span><br><span class="line">    User sana</span><br><span class="line">    IdentityFile ~/.ssh/target</span><br><span class="line">    ProxyCommand ssh -q -W %h:%p jump-box</span><br></pre></td></tr></table></figure><a id="more"></a><p>详见：<a href="https://code.visualstudio.com/blogs/2019/10/03/remote-ssh-tips-and-tricks" target="_blank" rel="noopener">remote-ssh-tips-and-tricks</a></p><p>但是这样太不方便了，两台服务器，配置过于复杂了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>可以通过git自带的connect.exe来完成，可以在git安装目录中找到这个exe文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host xxx.xxx.xxx.xxx</span><br><span class="line">  HostName xxx.xxx.xxx.xxx</span><br><span class="line">  User root</span><br><span class="line">  ProxyCommand C:\\Program\ Files\\Git\\mingw64\\bin\\connect.exe -H 127.0.0.1:1081 %h %p</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>vscode常规代理配置方法，是在运行时需要通过命令行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vscode --proxy-server=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自建KMS服务</title>
      <link href="/2019/12/19/%E8%87%AA%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/12/19/%E8%87%AA%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="自建KMS服务"><a href="#自建KMS服务" class="headerlink" title="自建KMS服务"></a>自建KMS服务</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>项目地址：<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">Wind4/vlmcsd</a></p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>为了避免系统环境不同引发未知问题，在这里使用 Docker。<br>Ubuntu 安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>CentOS 安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装-vlmscd"><a href="#安装-vlmscd" class="headerlink" title="安装 vlmscd"></a>安装 vlmscd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mikolatero/vlmcsd</span><br><span class="line">docker run -d -p 1688:1688 --restart=always --name="vlmcsd" mikolatero/vlmcsd</span><br></pre></td></tr></table></figure><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>需要打开 1688 端口供 vlmcsd 使用。在这里举两个常用的。</p><h4 id="UFW"><a href="#UFW" class="headerlink" title="UFW"></a>UFW</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 1688</span><br></pre></td></tr></table></figure><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 1688 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 1688 -j ACCEPT</span><br></pre></td></tr></table></figure><p>完！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows &amp; Office KMS激活</title>
      <link href="/2019/12/19/Windows%20&amp;%20Office%20KMS%E6%BF%80%E6%B4%BB/"/>
      <url>/2019/12/19/Windows%20&amp;%20Office%20KMS%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-amp-Office-KMS激活"><a href="#Windows-amp-Office-KMS激活" class="headerlink" title="Windows &amp; Office KMS激活"></a>Windows &amp; Office KMS激活</h1><h2 id="激活办法"><a href="#激活办法" class="headerlink" title="激活办法"></a>激活办法</h2><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>如果安装的系统不是VL版本，也可以通过重新安装GVLK KEY变成VL版。（文章最下面查找GVLK）</p><p>查找自己的系统版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic os get caption</span><br></pre></td></tr></table></figure><p>激活命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slmgr.vbs -upk</span><br><span class="line">slmgr.vbs -ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXX</span><br><span class="line">slmgr.vbs -skms kms地址</span><br><span class="line">slmgr.vbs -ato</span><br><span class="line">slmgr.vbs -dlv</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h2><p>如果安装的Office不是VL版本，也可以通过重新安装GVLK KEY变成VL版。（文章最下面查找GVLK）</p><p>找到office安装目录，在命令行切换过去，比如Office2016：</p><ul><li>32位：<code>C:\Program Files (x86)\Microsoft Office\Office16</code></li><li>64位：<code>C:\Program Files\Microsoft Office\Office16</code></li></ul><p>office16是office2016，office15就是2013，office14就是2010.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd \Program Files\Microsoft Office\Office16</span><br><span class="line">cscript ospp.vbs /sethst:kms地址</span><br><span class="line">cscript ospp.vbs /inpkey:xxxxx-xxxxx-xxxxx-xxxxx-xxxxx</span><br><span class="line">cscript ospp.vbs /act</span><br><span class="line">cscript ospp.vbs /dstatusall</span><br></pre></td></tr></table></figure><h2 id="GVLK-KEY查询"><a href="#GVLK-KEY查询" class="headerlink" title="GVLK KEY查询"></a>GVLK KEY查询</h2><blockquote><p>office2016 <a href="https://technet.microsoft.com/zh-cn/library/dn385360(v=office.16).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/library/dn385360(v=office.16).aspx</a></p><p>office2013 <a href="https://technet.microsoft.com/ZH-CN/library/dn385360.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/ZH-CN/library/dn385360.aspx</a></p><p>office2010 <a href="https://technet.microsoft.com/ZH-CN/library/ee624355(v=office.14).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/ZH-CN/library/ee624355(v=office.14).aspx</a></p><p>Server/Windows <a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置Powershell命令行代理</title>
      <link href="/2019/08/11/%E9%85%8D%E7%BD%AEPowershell%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2019/08/11/%E9%85%8D%E7%BD%AEPowershell%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在日常windows环境开发中，powershell经常需要用到代理，但是每次去系统变量中配置环境变量还是显得过于麻烦了，所以我们可以定义两个命令：</p><ul><li>应用代理环境变量</li><li>取消代理环境变量</li></ul><p>直接在powershell中调用这两命令就方便很多了。</p><h2 id="Powershell基本概念"><a href="#Powershell基本概念" class="headerlink" title="Powershell基本概念"></a>Powershell基本概念</h2><p>Powershell中不像bash那样所有东西都是字符串，它支持对象，比如环境变量是存放在Env对象中的，添加和移除环境变量都是操作Env这个对象。</p><a id="more"></a><p>操作对象的方式（以环境变量为例）：</p><ul><li>添加/修改一个键值对：<code>Set-Item Env:http_proxy = &quot;http://127.0.0.1:1080&quot;</code></li><li>移除一个键值对：<code>Remove-Item Env:http_proxy</code></li></ul><p>知道这个就能配置代理了。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>我们需要将这两个命令写入powershell启动脚本（类似linux的<code>.bashrc</code>），windows启动脚本在哪儿？<a href="/2019/08/11/Powershell启动脚本/" title="点击这里">点击这里</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_proxy_variable</span></span> &#123;</span><br><span class="line"><span class="built_in">Set-Item</span> Env:http_proxy <span class="string">"http://127.0.0.1:1080"</span>  <span class="comment"># 代理地址</span></span><br><span class="line"><span class="built_in">Set-Item</span> Env:https_proxy <span class="string">"http://127.0.0.1:1080"</span> <span class="comment"># 代理地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unset_proxy_variable</span></span> &#123;</span><br><span class="line">    <span class="built_in">Remove-Item</span> Env:http_proxy</span><br><span class="line">    <span class="built_in">Remove-Item</span> Env:https_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> spp <span class="literal">-Value</span> set_proxy_variable</span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> upp <span class="literal">-Value</span> unset_proxy_variable</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>如果打开新的poewrshell窗口报<code>此系统上禁止运行脚本</code>错误，需要设置运行策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><code>spp</code> 启用代理</li><li><code>upp</code> 取消代理</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Powershell启动脚本</title>
      <link href="/2019/08/11/Powershell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/08/11/Powershell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>Linux中bash有一个启动的默认配置文件：<code>.bashrc</code>或者<code>.bash_profile</code>，自定义命令以及预配置可以写在那里，但是windows的配置文件在哪里呢？</p><p>按照微软官网的说法是按照以下的对应关系，但是实际上是不对的。</p><table><thead><tr><th align="left">Description</th><th align="left">Path</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PsHome\Profile.ps1</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PsHome\Microsoft.PowerShell_profile.ps1</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$Home\[My ]Documents\PowerShell\Profile.ps1</code></td></tr><tr><td align="left">Current user, Current Host</td><td align="left"><code>$Home\[My ]Documents\PowerShell\ Microsoft.PowerShell_profile.ps1</code></td></tr></tbody></table><a id="more"></a><p>我们可以通过环境变量查看配置文件的路径</p><table><thead><tr><th align="left">Description</th><th align="left">Name</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PROFILE.AllUsersAllHosts</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PROFILE.AllUsersCurrentHost</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$PROFILE.CurrentUserAllHosts</code></td></tr><tr><td align="left">Current User, Current Host</td><td align="left"><code>$PROFILE</code> or <code>$PROFILE.CurrentUserCurrentHost</code></td></tr></tbody></table><p>windows 10 1903版本上的配置文件的实际路径</p><table><thead><tr><th align="left">Description</th><th align="left">Path</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PsHome\profile.ps1</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PsHome\Microsoft.PowerShell_profile.ps1</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$Home\Documents\WindowsPowerShell\profile.ps1</code></td></tr><tr><td align="left">Current user, Current Host</td><td align="left"><code>$Home\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></td></tr></tbody></table><p>然后就是按照路径创建配置文件，终于可以写点自定义命令了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 18.04开启bbr</title>
      <link href="/2019/03/04/ubuntu%2018.04%E5%BC%80%E5%90%AFbbr/"/>
      <url>/2019/03/04/ubuntu%2018.04%E5%BC%80%E5%90%AFbbr/</url>
      
        <content type="html"><![CDATA[<p><strong>说明：</strong><code>Ubuntu 18.04</code>前几天发布了，改变挺大的，内核也直接升到了正式版<code>4.15</code>，而<code>BBR</code>内核要求为<code>4.9</code>，也就是说满足了，所以我们不需要换内核就可以很快的开启<code>BBR</code>，这里简单说下方法。<br><a name="ea340b9d"></a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1、修改系统变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、保存生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>3、查看内核是否已开启BBR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>显示以下即已开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_available_congestion_control</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure><p>4、查看BBR是否启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>显示以下即启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsmod | grep bbr</span></span><br><span class="line">tcp_bbr                20480  14</span><br></pre></td></tr></table></figure><p><a href="https://www.moerats.com/archives/612/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xshell调整tmux大小无效问题</title>
      <link href="/2019/03/04/Xshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/04/Xshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>使用xshell的时候发现tmux的pane大小只能左右调节不能上下调节，后台发现xshell不响应ctrl+up和ctrl+down快捷键，只能自己设置快捷键。</p><p>两个组合键输出的特殊字符是<code>[1;5A</code>和<code>[1;5B</code>，但是在开头还隐藏了一个代表<code>esc</code>的特殊字符<code>\033</code>。xshell工具-&gt;选项-&gt;键盘和鼠标-&gt;编辑-&gt;新建，按对应快捷键，类型选择发送字符串，粘贴以下对应的字符串，完成。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\033[1;5A =&gt; ctrl+up</span><br><span class="line">\033[1;5B =&gt; ctrl+down</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tmux常用命令以及快捷键</title>
      <link href="/2019/03/04/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><a name="dbb0d3bb"></a></p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><table><thead><tr><th align="left">tmux new[-session] -s $session_name -d</th><th align="left">新建会话(-d 是否在后台)</th></tr></thead><tbody><tr><td align="left">tmux new -s name -n $window_name</td><td align="left">新建会话及窗口</td></tr><tr><td align="left">tmux at[tach] -t session</td><td align="left">重新连接(-t 后接会话名称)</td></tr><tr><td align="left">tmux ls</td><td align="left">显示保存的会话</td></tr><tr><td align="left">tmux kill-session -t $session_name</td><td align="left">删除会话</td></tr></tbody></table><a id="more"></a><p><a name="887aaa1f"></a></p><h2 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prefix: ctrl+b</span><br><span class="line"></span><br><span class="line">prefix `&#123; / &#125;` 左右pane交换</span><br><span class="line">prefix `&quot;`: 上下分割</span><br><span class="line">prefix `%`: 左右分割</span><br><span class="line">prefix `方向键`: focus到相应的panel上</span><br><span class="line">prefix `o`: focus 到下一个pannel上 </span><br><span class="line">prefix `d`: 推出并保存工作区  `tmux attach` 恢复</span><br><span class="line">prefix `&amp;`: 关闭工作区，无法保存</span><br><span class="line">prefix `:kill-session`: 关闭当前session</span><br><span class="line">prefix `d`: 临时退出session</span><br><span class="line">prefix `:kill-server`: 关闭所有session</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NERD tree 配置命令以及快捷键</title>
      <link href="/2019/03/04/NERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/NERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><a name="57fc581c"></a></p><h2 id="NERD-tree-配置"><a href="#NERD-tree-配置" class="headerlink" title="NERD tree 配置"></a>NERD tree 配置</h2><p>使用F2快速展开或隐藏它打开vim时自动展开NERDTree</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd vimenter * <span class="keyword">if</span> !argc() | NERDTree | endif</span><br></pre></td></tr></table></figure><p>如果窗口除了NERDTree没有其他文件时，自动关闭，可以减少多次按:q</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd bufenter * <span class="keyword">if</span> (winnr(<span class="string">"$"</span>) == 1 &amp;&amp; exists(<span class="string">"b:NERDTreeType"</span>) &amp;&amp; b:NERDTreeType == <span class="string">"primary"</span>) | q | endif</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用F2快速展开或隐藏它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><p><a name="ddf7d2a5"></a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br></pre></td></tr></table></figure><p><a name="f7d29966"></a></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">shift + a   侧边栏宽度放大，再按一下恢复</span><br><span class="line"></span><br><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br><span class="line"></span><br><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><p><a name="d41d8cd9"></a></p><p>## </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim常用快捷键</title>
      <link href="/2019/03/04/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">v：按字符选择。经常使用的模式，所以亲自尝试一下它。</span><br><span class="line"></span><br><span class="line">V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。</span><br><span class="line"></span><br><span class="line">一、移动光标</span><br><span class="line">1、左移h、右移l、下移j、上移k</span><br><span class="line">2、向下翻页ctrl + f，向上翻页ctrl + b</span><br><span class="line">3、向下翻半页ctrl + d，向上翻半页ctrl + u</span><br><span class="line">4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</span><br><span class="line">5、移动光标到下一个句子 ），移动光标到上一个句子（</span><br><span class="line">6、移动到段首&#123;，移动到段尾&#125;</span><br><span class="line">7、移动到下一个词w，移动到上一个词b</span><br><span class="line">8、移动到文档开始gg，移动到文档结束G</span><br><span class="line">9、移动到匹配的&#123;&#125;.().[]处%</span><br><span class="line">10、跳到第n行 ngg 或 nG 或 :n</span><br><span class="line">11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</span><br><span class="line">12、读取当前字符，并移动到本屏幕内下一次出现的地方 *</span><br><span class="line">13、读取当前字符，并移动到本屏幕内上一次出现的地方 #</span><br><span class="line"></span><br><span class="line">二、查找替换</span><br><span class="line">1、光标向后查找关键字 #或者g#</span><br><span class="line">2、光标向前查找关键字 *或者g*</span><br><span class="line">3、当前行查找字符 fx, Fx, tx, Tx</span><br><span class="line">4、基本替换 :s/s1/s2 （将下一个s1替换为s2）</span><br><span class="line">5、全部替换 :%s/s1/s2</span><br><span class="line">6、只替换当前行 :s/s1/s2/g</span><br><span class="line">7、替换某些行 :n1,n2 s/s1/s2/g</span><br><span class="line">8、搜索模式为 /string，搜索下一处为n，搜索上一处为N</span><br><span class="line">9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母</span><br><span class="line">10、移动到某标签处 `x，1旁边的键</span><br><span class="line">11、移动到上次编辑文件的位置 `.</span><br><span class="line"></span><br><span class="line">PS：.代表一个任意字符 *代表一个或多个字符的重复</span><br><span class="line">         正则表达式的内容将会在后续文章中整理</span><br><span class="line"></span><br><span class="line">三、编辑操作</span><br><span class="line">1、光标后插入a, 行尾插入A</span><br><span class="line">2、后插一行插入o，前插一行插入O</span><br><span class="line">3、删除字符插入s， 删除正行插入S</span><br><span class="line">4、光标前插入i，行首插入I</span><br><span class="line">5、删除一行dd，删除后进入插入模式cc或者S</span><br><span class="line">6、删除一个单词dw，删除一个单词进入插入模式cw</span><br><span class="line">7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</span><br><span class="line">8、粘贴p，交换两个字符xp，交换两行ddp</span><br><span class="line">9、复制y，复制一行yy</span><br><span class="line">10、撤销u，重做ctrl + r，重复.</span><br><span class="line">11、智能提示 ctrl + n 或者 ctrl + p</span><br><span class="line">12、删除motion跨过的字符，删除并进入插入模式 c&#123;motion&#125;</span><br><span class="line">13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</span><br><span class="line">14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</span><br><span class="line">15、删除motion跨过的字符，删除但不进入插入模式 d&#123;motion&#125;</span><br><span class="line">16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</span><br><span class="line">17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx</span><br><span class="line">18、如果只是复制的情况时，将12-17条中的c或d改为y</span><br><span class="line">19、删除到行尾可以使用D或C</span><br><span class="line">20、拷贝当前行 yy或者Y</span><br><span class="line">21、删除当前字符 x</span><br><span class="line">22、粘贴 p</span><br><span class="line">23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</span><br><span class="line">24、重复执行上一个作用使用.</span><br><span class="line">25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</span><br><span class="line">26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</span><br><span class="line">27、 &gt;&gt; 缩进所有选择的代码</span><br><span class="line">28、 &lt;&lt; 反缩进所有选择的代码</span><br><span class="line">29、gd 移动到光标所处的函数或变量的定义处</span><br><span class="line">30、K 在man里搜索光标所在的词</span><br><span class="line">31、合并两行 J</span><br><span class="line">32、若不想保存文件，而重新打开 :e!</span><br><span class="line">33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</span><br><span class="line"></span><br><span class="line">四、窗口操作</span><br><span class="line">1、分隔一个窗口:split或者:vsplit</span><br><span class="line">2、创建一个窗口:new或者:vnew</span><br><span class="line">3、在新窗口打开文件:sf &#123;filename&#125;</span><br><span class="line">4、关闭当前窗口:close</span><br><span class="line">5、仅保留当前窗口:only</span><br><span class="line">6、到左边窗口 ctrl + w, h</span><br><span class="line">7、到右边窗口 ctrl + w, l</span><br><span class="line">8、到上边窗口 ctrl + w, k</span><br><span class="line">9、到下边窗口 ctrl + w, j</span><br><span class="line">10、到顶部窗口 ctrl + w, t</span><br><span class="line">11、到底部窗口 ctrl + w, b</span><br><span class="line"></span><br><span class="line">五、宏操作</span><br><span class="line">1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</span><br><span class="line">2、@[a-z]执行寄存器[a-z]中的操作</span><br><span class="line">3、@@执行最近一次记录的宏操作</span><br><span class="line"></span><br><span class="line">六、可视操作</span><br><span class="line">1、进入块可视模式 ctrl + v</span><br><span class="line">2、进入字符可视模式 v</span><br><span class="line">3、进入行可视模式 V</span><br><span class="line">4、删除选定的块 d</span><br><span class="line">5、删除选定的块然后进入插入模式 c</span><br><span class="line">6、在选中的块同是插入相同的字符 I&lt;String&gt;ESC</span><br><span class="line"></span><br><span class="line">七、跳到声明</span><br><span class="line">1、[[ 向前跳到顶格第一个&#123;  </span><br><span class="line">2、[] 向前跳到顶格第一个&#125;</span><br><span class="line">3、]] 向后跳到顶格的第一个&#123;</span><br><span class="line">4、]] 向后跳到顶格的第一个&#125;</span><br><span class="line">5、[&#123; 跳到本代码块的开头</span><br><span class="line">6、]&#125; 跳到本代码块的结尾</span><br><span class="line"></span><br><span class="line">八、挂起操作</span><br><span class="line">1、挂起Vim ctrl + z 或者 :suspend</span><br><span class="line">2、查看任务 在shell中输入 jobs</span><br><span class="line">3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</span><br><span class="line">4、执行shell命令 :!command</span><br><span class="line">5、开启shell命令 :shell，退出该shell exit</span><br><span class="line">6、保存vim状态 :mksession name.vim</span><br><span class="line">7、恢复vim状态 :source name.vim</span><br><span class="line">8、启动vim时恢复状态 vim -S name.vim</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux无损调整分区大小</title>
      <link href="/2019/03/04/Linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
      <url>/2019/03/04/Linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p><a name="c931653c"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>500G 硬盘</p><pre><code>100MB `boot`分区 |8G `swap`分区 |450G `/`分区</code></pre><p>我需要将<code>/home</code>分区单独提取一个分区出来，即变成</p><pre><code>100MB `boot`分区 |8G `swap`分区 |100G `/`分区 |350G `/home`分区</code></pre><p><a name="52b36576"></a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>sudo e2fsck -fy /dev/sda3 // f 是表示检查，y表示一直确认，直到修复完</li><li>sudo resize2fs /dev/sda3 100G  //将文件系统调整到50G（不太明白文件系统大小和分区大小的关系）</li><li>sudo fdisk /dev/sda  // 使用fdisk进行分区</li><li>首先输入p，查看要调整分区（sda3）的start序号（重要）</li><li>输入 <code>d</code> 删除要sda3，选择3</li><li>输入 <code>n</code> 添加一个主分区，分区号选择3</li><li>选择<code>start</code>地址，就是刚才查看的地址（一般不用修改，默认就是刚才的值）</li><li>选择分区容量，输入<code>+100G</code></li><li>然后再新建一个分区，输入n，选择p（主分区），选择默认起点，再选择默认终点</li><li>按w保存分区表<ol><li>这里有可能会报错，什么device被占用之类的错误</li><li>使用 <code>partprobe /dev/sda</code>命令重载/dev/sda 重载分区表，（命令成功界面没有显示）</li></ol></li><li><code>sudo e2fsck -fy /dev/sda3</code> 修复sda3分区</li><li><code>sudo resize2fs /dev/sda3</code> 检查一下有没有问题</li><li>sda3分区已经没有问题了，数据全部都保留着。</li><li>格式化sda4 <code>sudo mkfs.ext4 /dev/sda4</code></li><li>然后就是迁移所有<code>/home</code>数据到<code>sda4</code></li><li>在fstab中添加一行  <code>UUID=xxxxxxxxxxxxxxx /home ext4 defaults 0 0</code></li><li>开机后使用<code>sudo chown -R username:username /home/fan</code>，否则由于权限问题导致无法登录</li></ol><a id="more"></a><p>大功告成！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux创建开机启动服务</title>
      <link href="/2019/03/04/Linux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/03/04/Linux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><a name="e6cefb85"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>使用linux离不开ss，每次都需要手动输入命令开启，很麻烦，所以需要创建开机就启动的服务。<br><a name="a62d8a1a"></a></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>假设我们有一段需要开机启动的服务脚本<code>/home/username/document/ss-local.sh</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-local -c /home/username/document/ssconfig.json</span><br></pre></td></tr></table></figure><a id="more"></a><p><a name="c010aa73"></a></p><h2 id="创建服务（两种方式）"><a href="#创建服务（两种方式）" class="headerlink" title="创建服务（两种方式）"></a>创建服务（两种方式）</h2><p><a name="b3ffe560"></a></p><h3 id="1-创建成系统服务"><a href="#1-创建成系统服务" class="headerlink" title="1. 创建成系统服务"></a>1. 创建成系统服务</h3><p>然后在<code>/etc/init.d/</code>新建<code>ss-local</code>文件，注意这个文件的写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          ss-local // 名字要和文件名一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$remote_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$remote_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:    2 3 4 5 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:     0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: <span class="built_in">local</span> shadowsocks service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line">NAME=ss-local</span><br><span class="line">DEAMON=/home/username/document/ss-local.sh  # 注意设置正确的脚本路径</span><br><span class="line"></span><br><span class="line">start_sslocal() &#123;</span><br><span class="line">    start-stop-daemon --start --background --name $NAME --exec $DEAMON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_sslocal() &#123;</span><br><span class="line">    start-stop-daemon --stop --name $NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case "$1" in  </span><br><span class="line">  start|"")</span><br><span class="line">        start_sslocal</span><br><span class="line">        ;;  </span><br><span class="line">  restart|reload|force-reload)</span><br><span class="line">        stop_sslocal</span><br><span class="line">        ;;  </span><br><span class="line">  stop)</span><br><span class="line">        exit 0 </span><br><span class="line">        ;;  </span><br><span class="line">  *)  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>将文件的权限置为755</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 ss-local</span><br></pre></td></tr></table></figure><p>将服务文件设置为开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d ss-local defaults</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ss-local</span><br></pre></td></tr></table></figure><p><a name="f82206a2"></a></p><h3 id="2-创建成systemd服务"><a href="#2-创建成systemd服务" class="headerlink" title="2. 创建成systemd服务"></a>2. 创建成systemd服务</h3><p>定位到<code>/usr/lib/systemd/system</code>目录（如果没有就新建），新建ss-local.service。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="meta">#</span><span class="bash">定义描述</span></span><br><span class="line">Description=The ss-local service</span><br><span class="line"><span class="meta">#</span><span class="bash">指定了在systemd在执行完那些target之后再启动该服务</span></span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span><span class="bash">定义Service 的运行<span class="built_in">type</span>，一般是forking，就是后台运行</span></span><br><span class="line">Type=simple</span><br><span class="line"><span class="meta">#</span><span class="bash">以下定义systemctl start |stop |reload *.service  的每个执行方法，具体命令<span class="comment">#需要&gt;写绝对路径</span></span></span><br><span class="line">ExecStart=/home/fan/Documents/ss/ss-local.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">创建私有的内存临时空间</span></span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后就可以设置开机启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开机启动</span></span><br><span class="line">sudo systemctl enable ss-local.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">sudo systemctl start ss-local.service</span><br></pre></td></tr></table></figure><p>完</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript变态题</title>
      <link href="/2018/03/22/javascript%E5%8F%98%E6%80%81%E9%A2%98/"/>
      <url>/2018/03/22/javascript%E5%8F%98%E6%80%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>原帖： <a href="https://github.com/xiaoyu2er/blog/issues/1" target="_blank" rel="noopener">https://github.com/xiaoyu2er/blog/issues/1</a><br><br>原题来自: <a href="http://javascript-puzzlers.herokuapp.com/" target="_blank" rel="noopener">javascript-puzzlers</a></p><p>读者可以先去做一下感受感受. 当初笔者的成绩是 21/44…</p><p>当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了….</p><p>不过, 对于基础知识的理解是深入编程的前提. 让我们一起来看看这些变态题到底变态不变态吧!</p><a id="more"></a><p><a name="6e32403c"></a></p><h2 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Array/map</li><li>Number/parseInt</li><li>Global_Objects/parseInt</li><li>JavaScript parseInt</li></ul><p>首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值</p><p>其中回调函数接受三个参数 currentValue, index, arrary;</p><p>而题目中, map只传入了回调函数–parseInt.</p><p>其次, parseInt 只接受两个两个参数 string, radix(基数).</p><p>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：</p><p>如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).<br><br>如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。<br><br>如果字符串 string 以其它任何值开头，则基数是10 (十进制)。<br><br>所以本题即问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0);</span><br><span class="line">parseInt(&apos;2&apos;, 1);</span><br><span class="line">parseInt(&apos;3&apos;, 2);</span><br></pre></td></tr></table></figure><p>首先后两者参数不合法.</p><p>所以答案是 [1, NaN, NaN]</p><p><a name="6455193a"></a></p><h2 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Operators/typeof</li><li>Operators/instanceof</li><li>Operators/instanceof(中)</li></ul><p>typeof 返回一个表示类型的字符串.</p><p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p><p>这个题可以直接看链接… 因为 typeof null === ‘object’ 自语言之初就是这样….</p><p>typeof 的结果请看下表:</p><table><thead><tr><th>type</th><th align="center">result</th></tr></thead><tbody><tr><td>Undefined</td><td align="center">“undefined”</td></tr><tr><td>Null</td><td align="center">“object”</td></tr><tr><td>Boolean</td><td align="center">“boolean”</td></tr><tr><td>Number</td><td align="center">“number”</td></tr><tr><td>String</td><td align="center">“string”</td></tr><tr><td>Symbol</td><td align="center">“symbol”</td></tr><tr><td>Host object</td><td align="center">Implementation-dependent</td></tr><tr><td>Function</td><td align="center">“function”</td></tr><tr><td>Object</td><td align="center">“object”</td></tr></tbody></table><p>所以答案 [object, false]</p><p><a name="62d27b2f"></a></p><h2 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Array/Reduce</li><li>arr.reduce(callback[, initialValue])</li></ul><p>reduce接受两个参数, 一个回调, 一个初始值.</p><p>回调函数接受四个参数 previousValue, currentValue, currentIndex, array</p><p>需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.</p><p>所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</p><p>答案 an error</p><p><a name="146b01ec"></a></p><h2 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var val = &apos;smtg&apos;;</span><br><span class="line">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Operators/Operator_Precedence</li><li>Operators/Conditional_Operator</li></ul><p>简而言之 + 的优先级 大于 ?</p><p>所以原题等价于 ‘Value is true’ ? ‘Somthing’ : ‘Nonthing’ 而不是 ‘Value is’ + (true ? ‘Something’ : ‘Nonthing’)</p><p>答案 ‘Something’</p><p><a name="572d97b6"></a></p><h2 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        var name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这个相对简单, 一个知识点:</p><p>Hoisting<br><br>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</p><p>这个题目相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var name;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>所以答案是 ‘Goodbye Jack’</p><p><a name="66956306"></a></p><h2 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var END = Math.pow(2, 53);</span><br><span class="line">var START = END - 100;</span><br><span class="line">var count = 0;</span><br><span class="line">for (var i = START; i &lt;= END; i++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">console.log(count);</span><br></pre></td></tr></table></figure><p>一个知识点:</p><p>Infinity<br><br>在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.</p><p>js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。<br><br>2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。<br><br>9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。</p><p><a name="628ffa72"></a></p><h2 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary = [0,1,2];</span><br><span class="line">ary[10] = 10;</span><br><span class="line">ary.filter(function(x) &#123; return x === undefined;&#125;);</span><br></pre></td></tr></table></figure><p>答案是 []</p><p>看一篇文章理解稀疏数组</p><p>译 JavaScript中的稀疏数组与密集数组<br><br>Array/filter<br><br>我们来看一下 Array.prototype.filter 的 polyfill:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.prototype.filter) &#123;</span><br><span class="line">  Array.prototype.filter = function(fun/*, thisArg*/) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    if (this === void 0 || this === null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var t = Object(this);</span><br><span class="line">    var len = t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (typeof fun !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var res = [];</span><br><span class="line">    var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      if (i in t) &#123; // 注意这里!!!</span><br><span class="line">        var val = t[i];</span><br><span class="line">        if (fun.call(thisArg, val, i, t)) &#123;</span><br><span class="line">          res.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</p><p>0 in ary; =&gt; true<br><br>3 in ary; =&gt; false<br><br>10 in ary; =&gt; true<br><br>也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.</p><p><a name="1c19082a"></a></p><h2 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var two   = 0.2</span><br><span class="line">var one   = 0.1</span><br><span class="line">var eight = 0.8</span><br><span class="line">var six   = 0.6</span><br><span class="line">[two - one == one, eight - six == two]</span><br></pre></td></tr></table></figure><p>JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3<br><br>IEEE 754标准中的浮点数并不能精确地表达小数</p><p>那什么时候精准, 什么时候不经准呢? 笔者也不知道…</p><p>答案 [true, false]</p><p><a name="ac4aabec"></a></p><h2 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function showCase(value) &#123;</span><br><span class="line">    switch(value) &#123;</span><br><span class="line">    case &apos;A&apos;:</span><br><span class="line">        console.log(&apos;Case A&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case &apos;B&apos;:</span><br><span class="line">        console.log(&apos;Case B&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case undefined:</span><br><span class="line">        console.log(&apos;undefined&apos;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&apos;Do not know!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(new String(&apos;A&apos;));</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Statements/switch</li><li>String</li></ul><p>switch 是严格比较, String 实例和 字符串不一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s_prim = &apos;foo&apos;;</span><br><span class="line">var s_obj = new String(s_prim);</span><br><span class="line"></span><br><span class="line">console.log(typeof s_prim); // &quot;string&quot;</span><br><span class="line">console.log(typeof s_obj);  // &quot;object&quot;</span><br><span class="line">console.log(s_prim === s_obj); // false</span><br></pre></td></tr></table></figure><p>答案是 ‘Do not know!’</p><p><a name="88decc9a"></a></p><h2 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function showCase2(value) &#123;</span><br><span class="line">    switch(value) &#123;</span><br><span class="line">    case &apos;A&apos;:</span><br><span class="line">        console.log(&apos;Case A&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case &apos;B&apos;:</span><br><span class="line">        console.log(&apos;Case B&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case undefined:</span><br><span class="line">        console.log(&apos;undefined&apos;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&apos;Do not know!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase2(String(&apos;A&apos;));</span><br></pre></td></tr></table></figure><p>解释:<br><br>String(x) does not create an object but does return a string, i.e. typeof String(1) === “string”</p><p>还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.</p><p>答案 ‘Case A’</p><p><a name="e5bdb41c"></a></p><h2 id="第11题"><a href="#第11题" class="headerlink" title="第11题"></a>第11题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isOdd(num) &#123;</span><br><span class="line">    return num % 2 == 1;</span><br><span class="line">&#125;</span><br><span class="line">function isEven(num) &#123;</span><br><span class="line">    return num % 2 == 0;</span><br><span class="line">&#125;</span><br><span class="line">function isSane(num) &#123;</span><br><span class="line">    return isEven(num) || isOdd(num);</span><br><span class="line">&#125;</span><br><span class="line">var values = [7, 4, &apos;13&apos;, -9, Infinity];</span><br><span class="line">values.map(isSane);</span><br></pre></td></tr></table></figure><p>一个知识点</p><p>Arithmetic_Operators#Remainder<br><br>此题等价于</p><p>7 % 2 =&gt; 1<br><br>4 % 2 =&gt; 0<br><br>‘13’ % 2 =&gt; 1<br><br>-9 % % 2 =&gt; -1<br><br>Infinity % 2 =&gt; NaN<br><br>需要注意的是 余数的正负号随第一个操作数.</p><p>答案 [true, true, true, false, false]</p><p><a name="d6be270d"></a></p><h2 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(3, 8)</span><br><span class="line">parseInt(3, 2)</span><br><span class="line">parseInt(3, 0)</span><br></pre></td></tr></table></figure><p>第一个题讲过了, 答案 3, NaN, 3</p><p><a name="4226b3dd"></a></p><h2 id="第13题"><a href="#第13题" class="headerlink" title="第13题"></a>第13题</h2><p>Array.isArray( Array.prototype )<br><br>一个知识点:</p><p>Array/prototype<br><br>一个鲜为人知的实事: Array.prototype =&gt; [];</p><p>答案: true</p><p><a name="363c2f15"></a></p><h2 id="第14题"><a href="#第14题" class="headerlink" title="第14题"></a>第14题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [0];</span><br><span class="line">if ([0]) &#123;</span><br><span class="line">  console.log(a == true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&quot;wut&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript-Equality-Table<br><br>更新通过一张简单的图，让你彻底地、永久地搞懂JS的==运算 非常不错的一篇文章!<br><br>解析:</p><p>Boolean([0]) === true<br><br>[0] == true<br><br>true 转换为数字 =&gt; 1<br><br>[0] 转化为数字失败, 转化为字符串 ‘0’, 转化成数字 =&gt; 0<br><br>0 !== 1<br><br>答案: false</p><p><a name="b03895b5"></a></p><h2 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]==[]</span><br></pre></td></tr></table></figure><p>[] 是Object, 两个 Object 不相等</p><p>答案是 false</p><p><a name="04f071ac"></a></p><h2 id="第16题"><a href="#第16题" class="headerlink" title="第16题"></a>第16题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;5&apos; + 3</span><br><span class="line">&apos;5&apos; - 3</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Arithmetic_Operators#Addition</li><li>Arithmetic_Operators#Subtraction</li></ul><p>用来表示两个数的和或者字符串拼接, -表示两数之差.</p><p>请看例子, 体会区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;5&apos; + 3</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 + &apos;3&apos;</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 - &apos;3&apos;</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - 3</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - &apos;3&apos;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>也就是说 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接.</p><p>答案是 ‘53’, 2</p><p><a name="04355b99"></a></p><h2 id="第17题"><a href="#第17题" class="headerlink" title="第17题"></a>第17题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + - + + + - + 1</span><br></pre></td></tr></table></figure><p>这里应该是(倒着看)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 + (a)  =&gt; 2</span><br><span class="line">a = - (b) =&gt; 1</span><br><span class="line">b = + (c) =&gt; -1</span><br><span class="line">c = + (d) =&gt; -1</span><br><span class="line">d = + (e) =&gt; -1</span><br><span class="line">e = + (f) =&gt; -1</span><br><span class="line">f = - (g) =&gt; -1</span><br><span class="line">g = + 1   =&gt; 1</span><br></pre></td></tr></table></figure><p>所以答案 2</p><p><a name="b307f51e"></a></p><h2 id="第18题"><a href="#第18题" class="headerlink" title="第18题"></a>第18题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary = Array(3);</span><br><span class="line">ary[0]=2</span><br><span class="line">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</span><br></pre></td></tr></table></figure><p>稀疏数组. 同第7题.</p><p>题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.</p><p>所以答案是 [“1”, undefined × 2]</p><p>这里贴上 Array.prototype.map 的 polyfill.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map = function(callback, thisArg) &#123;</span><br><span class="line"></span><br><span class="line">        var T, A, k;</span><br><span class="line"></span><br><span class="line">        if (this == null) &#123;</span><br><span class="line">            throw new TypeError(&apos; this is null or not defined&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var O = Object(this);</span><br><span class="line">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class="line">        if (typeof callback !== &apos;function&apos;) &#123;</span><br><span class="line">            throw new TypeError(callback + &apos; is not a function&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arguments.length &gt; 1) &#123;</span><br><span class="line">            T = thisArg;</span><br><span class="line">        &#125;</span><br><span class="line">        A = new Array(len);</span><br><span class="line">        k = 0;</span><br><span class="line">        while (k &lt; len) &#123;</span><br><span class="line">            var kValue, mappedValue;</span><br><span class="line">            if (k in O) &#123;</span><br><span class="line">                kValue = O[k];</span><br><span class="line">                mappedValue = callback.call(T, kValue, k, O);</span><br><span class="line">                A[k] = mappedValue;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><a name="9323d012"></a></p><h2 id="第19题"><a href="#第19题" class="headerlink" title="第19题"></a>第19题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sidEffecting(ary) &#123;</span><br><span class="line">  ary[0] = ary[2];</span><br><span class="line">&#125;</span><br><span class="line">function bar(a,b,c) &#123;</span><br><span class="line">  c = 10</span><br><span class="line">  sidEffecting(arguments);</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1)</span><br></pre></td></tr></table></figure><p>这是一个大坑, 尤其是涉及到 ES6语法的时候</p><p>知识点:</p><p>Functions/arguments<br><br>首先 The arguments object is an Array-like object corresponding to the arguments passed to a function.</p><p>也就是说 arguments 是一个 object, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.</p><p>所以答案是 21.</p><p>然而!!!!!!</p><p>当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了…..</p><p>请看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sidEffecting(ary) &#123;</span><br><span class="line">  ary[0] = ary[2];</span><br><span class="line">&#125;</span><br><span class="line">function bar(a,b,c=3) &#123;</span><br><span class="line">  c = 10</span><br><span class="line">  sidEffecting(arguments);</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1)</span><br></pre></td></tr></table></figure><p>答案是 12 !!!!</p><p>请读者细细体会!!</p><p><a name="ec328372"></a></p><h2 id="第20题"><a href="#第20题" class="headerlink" title="第20题"></a>第20题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 111111111111111110000,</span><br><span class="line">    b = 1111;</span><br><span class="line">a + b;</span><br></pre></td></tr></table></figure><p>答案还是 111111111111111110000. 解释是 Lack of precision for numbers in JavaScript affects both small and big numbers. 但是笔者不是很明白……………. 请读者赐教!</p><p><a name="8e680b2c"></a></p><h2 id="第21题"><a href="#第21题" class="headerlink" title="第21题"></a>第21题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = [].reverse;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这个题有意思!</p><p>知识点:</p><ul><li>Array/reverse</li></ul><p>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</p><p>也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 window.</p><p>补充:</p><p><a href>stellar91 </a> 这个笔者实践了一下 发现 firefox 是 window, chrome 报错 VM190:2 Uncaught TypeError: Array.prototype.reverse called on null or undefined(…) 可能是实现不同, 在 chrome 中应该是对调用者做了检查. <br><br>答案是 window</p><p><a name="193cc324"></a></p><h2 id="第22题"><a href="#第22题" class="headerlink" title="第22题"></a>第22题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE &gt; 0</span><br></pre></td></tr></table></figure><p>true</p><p><a name="90106508"></a></p><h2 id="第23题"><a href="#第23题" class="headerlink" title="第23题"></a>第23题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</span><br></pre></td></tr></table></figure><p>这个题也还可以.</p><p>这个题会让人误以为是 2 &gt; 1 &amp;&amp; 2 &lt; 3 其实不是的.</p><p>这个题等价于</p><p>1 &lt; 2 =&gt; true;<br><br>true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;<br><br>3 &lt; 2 =&gt; false;<br><br>false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;<br><br>答案是 [true, true]</p><p><a name="e4881129"></a></p><h2 id="第24题"><a href="#第24题" class="headerlink" title="第24题"></a>第24题</h2><p>// the most classic wtf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 == [[[2]]]</span><br></pre></td></tr></table></figure><p>这个题我是猜的. 我猜的 true, 至于为什么…..</p><p>both objects get converted to strings and in both cases the resulting string is “2” 我不能信服…</p><p><a name="1c2a48a7"></a></p><h2 id="第25题"><a href="#第25题" class="headerlink" title="第25题"></a>第25题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.toString()</span><br><span class="line">3..toString()</span><br><span class="line">3...toString()</span><br></pre></td></tr></table></figure><p>这个题也挺逗, 我做对了 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f603.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt> 答案是 error, ‘3’, error</p><p>你如果换一个写法就更费解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">a.toString()</span><br></pre></td></tr></table></figure><p>这个答案就是 ‘3’;</p><p>为啥呢?</p><p>因为在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法啊!</p><p><a name="396db6e3"></a></p><h2 id="第26题"><a href="#第26题" class="headerlink" title="第26题"></a>第26题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var x = y = 1;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure><p>答案是 1, error</p><p>y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 ReferenceError</p><p><a name="17bd185d"></a></p><h2 id="第27题"><a href="#第27题" class="headerlink" title="第27题"></a>第27题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = /123/,</span><br><span class="line">    b = /123/;</span><br><span class="line">a == b</span><br><span class="line">a === b</span><br></pre></td></tr></table></figure><p>即使正则的字面量一致, 他们也不相等.</p><p>答案 false, false</p><p><a name="8146a75d"></a></p><h2 id="第28题"><a href="#第28题" class="headerlink" title="第28题"></a>第28题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3],</span><br><span class="line">    b = [1, 2, 3],</span><br><span class="line">    c = [1, 2, 4]</span><br><span class="line">a ==  b</span><br><span class="line">a === b</span><br><span class="line">a &gt;   c</span><br><span class="line">a &lt;   c</span><br></pre></td></tr></table></figure><p>字面量相等的数组也不相等.</p><p>数组在比较大小的时候按照字典序比较</p><p>答案 false, false, false, true</p><p><a name="68f766fa"></a></p><h2 id="第29题"><a href="#第29题" class="headerlink" title="第29题"></a>第29题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;, b = Object.prototype;</span><br><span class="line">[a.prototype === b, Object.getPrototypeOf(a) === b]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>Object/getPrototypeOf<br><br>只有 Function 拥有一个 prototype 的属性. 所以 a.prototype 为 undefined.</p><p>而 Object.getPrototypeOf(obj) 返回一个具体对象的原型(该对象的内部[[prototype]]值)</p><p>答案 false, true</p><p><a name="ffeb9319"></a></p><h2 id="第30题"><a href="#第30题" class="headerlink" title="第30题"></a>第30题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class="line">a === b</span><br><span class="line">f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.</span><br></pre></td></tr></table></figure><p>f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.</p><p>请看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === Object.getPrototypeOf(new f()) // true</span><br><span class="line">b === Function.prototype // true</span><br></pre></td></tr></table></figure><p>答案 false</p><p><a name="0ba0c1ef"></a></p><h2 id="第31题"><a href="#第31题" class="headerlink" title="第31题"></a>第31题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; &#125;</span><br><span class="line">var oldName = foo.name;</span><br><span class="line">foo.name = &quot;bar&quot;;</span><br><span class="line">[oldName, foo.name]</span><br></pre></td></tr></table></figure><p>答案 [‘foo’, ‘foo’]</p><p>知识点:</p><p>Function/name<br><br>因为函数的名字不可变.</p><p><a name="e5b74cc4"></a></p><h2 id="第32题"><a href="#第32题" class="headerlink" title="第32题"></a>第32题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1 2 3&quot;.replace(/\d/g, parseInt)</span><br></pre></td></tr></table></figure><p>知识点:</p><p>String/replace#Specifying_a_function_as_a_parameter<br><br>str.replace(regexp|substr, newSubStr|function)</p><p>如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数</p><p>match 首先是匹配的字符串<br><br>p1, p2 …. 然后是正则的分组<br><br>offset match 匹配的index<br><br>string 整个字符串<br><br>由于题目中的正则没有分组, 所以等价于问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0)</span><br><span class="line">parseInt(&apos;2&apos;, 2)</span><br><span class="line">parseInt(&apos;3&apos;, 4)</span><br></pre></td></tr></table></figure><p>答案: 1, NaN, 3</p><p><a name="32e50656"></a></p><h2 id="第33题"><a href="#第33题" class="headerlink" title="第33题"></a>第33题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">var parent = Object.getPrototypeOf(f);</span><br><span class="line">f.name // ?</span><br><span class="line">parent.name // ?</span><br><span class="line">typeof eval(f.name) // ?</span><br><span class="line">typeof eval(parent.name) //  ?</span><br></pre></td></tr></table></figure><p>先说以下答案 ‘f’, ‘Empty’, ‘function’, error 这个答案并不重要…..</p><p>这里第一小问和第三小问很简单不解释了.</p><p>第二小问笔者在自己的浏览器测试的时候是 ‘’, 第四问是 ‘undefined’</p><p>所以应该是平台相关的. 这里明白 parent === Function.prototype 就好了.</p><p><a name="66c25b05"></a></p><h2 id="第34题"><a href="#第34题" class="headerlink" title="第34题"></a>第34题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var lowerCaseOnly =  /^[a-z]+$/;</span><br><span class="line">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>RegExp/test<br><br>这里 test 函数会将参数转为字符串. ‘nul’, ‘undefined’ 自然都是全小写了</p><p>答案: true, true</p><p><a name="6fdb4ece"></a></p><h2 id="第35题"><a href="#第35题" class="headerlink" title="第35题"></a>第35题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[,,,].join(&quot;, &quot;)</span><br><span class="line">[,,,] =&gt; [undefined × 3]</span><br></pre></td></tr></table></figure><p>因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)</p><p>答案: “, , “</p><p><a name="83ddc935"></a></p><h2 id="第36题"><a href="#第36题" class="headerlink" title="第36题"></a>第36题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</span><br><span class="line">a.class</span><br></pre></td></tr></table></figure><p>这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了)</p><p>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’]</p><p><a name="a4ba204a"></a></p><h2 id="第37题"><a href="#第37题" class="headerlink" title="第37题"></a>第37题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = new Date(&quot;epoch&quot;)</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Date</li><li>Date/parse</li></ul><p>简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.</p><p>另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 Invalid Date.</p><p>答案 Invalid Date</p><p><a name="6a4d0417"></a></p><h2 id="第38题"><a href="#第38题" class="headerlink" title="第38题"></a>第38题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = Function.length,</span><br><span class="line">    b = new Function().length</span><br><span class="line">a === b</span><br></pre></td></tr></table></figure><p>我们知道一个function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0.</p><p>另外 Function.length 定义为1……</p><p>所以不相等…….答案 false</p><p><a name="9d1c9a97"></a></p><h2 id="第39题"><a href="#第39题" class="headerlink" title="第39题"></a>第39题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = Date(0);</span><br><span class="line">var b = new Date(0);</span><br><span class="line">var c = new Date();</span><br><span class="line">[a === b, b === c, a === c]</span><br></pre></td></tr></table></figure><p>还是关于Date 的题, 需要注意的是</p><p>如果不传参数等价于当前时间.<br><br>如果是函数调用 返回一个字符串.<br><br>答案 false, false, false</p><p><a name="8b9f16c2"></a></p><h2 id="第40题"><a href="#第40题" class="headerlink" title="第40题"></a>第40题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var min = Math.min(), max = Math.max()</span><br><span class="line">min &lt; max</span><br></pre></td></tr></table></figure><p>知识点:</p><p>Math/min<br><br>Math/max<br><br>有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f606.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>答案: false</p><p><a name="23237300"></a></p><h2 id="第41题"><a href="#第41题" class="headerlink" title="第41题"></a>第41题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function captureOne(re, str) &#123;</span><br><span class="line">  var match = re.exec(str);</span><br><span class="line">  return match &amp;&amp; match[1];</span><br><span class="line">&#125;</span><br><span class="line">var numRe  = /num=(\d+)/ig,</span><br><span class="line">    wordRe = /word=(\w+)/i,</span><br><span class="line">    a1 = captureOne(numRe,  &quot;num=1&quot;),</span><br><span class="line">    a2 = captureOne(wordRe, &quot;word=1&quot;),</span><br><span class="line">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</span><br><span class="line">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</span><br><span class="line">[a1 === a2, a3 === a4]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>RegExp/exec<br><br>通俗的讲</p><p>因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会</p><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myRe = /ab*/g;</span><br><span class="line">var str = &apos;abbcdefabh&apos;;</span><br><span class="line">var myArray;</span><br><span class="line">while ((myArray = myRe.exec(str)) !== null) &#123;</span><br><span class="line">  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</span><br><span class="line">  msg += &apos;Next match starts at &apos; + myRe.lastIndex;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">// Found abb. Next match starts at 3</span><br><span class="line">// Found ab. Next match starts at 9</span><br></pre></td></tr></table></figure><p>所以 a1 = ‘1’; a2 = ‘1’; a3 = null; a4 = ‘2’</p><p>答案 [true, false]</p><p><a name="8876f8c5"></a></p><h2 id="第42题"><a href="#第42题" class="headerlink" title="第42题"></a>第42题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Date(&quot;2014-03-19&quot;),</span><br><span class="line">    b = new Date(2014, 03, 19);</span><br><span class="line">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</span><br></pre></td></tr></table></figure><p>这个….</p><p>JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.getDay()</span><br><span class="line">3</span><br><span class="line">b.getDay()</span><br><span class="line">6</span><br><span class="line">a.getMonth()</span><br><span class="line">2</span><br><span class="line">b.getMonth()</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>都是套路!</p><p>答案 [false, false]</p><p><a name="9f4762dd"></a></p><h2 id="第43题"><a href="#第43题" class="headerlink" title="第43题"></a>第43题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</span><br><span class="line">  &apos;a gif file&apos;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &apos;not a gif file&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点:</p><p>String/match<br><br>String.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义<br><br>那么 /gif 就匹配了 /.gif/</p><p>答案: ‘a gif file’</p><p><a name="323e4f13"></a></p><h2 id="第44题"><a href="#第44题" class="headerlink" title="第44题"></a>第44题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">function bar(a) &#123;</span><br><span class="line">    var a = &apos;bye&apos;;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</span><br></pre></td></tr></table></figure><p>在两个函数里, a作为参数其实已经声明了, 所以 var a; var a = ‘bye’ 其实就是 a; a =’bye’</p><p>所以答案 ‘hello’, ‘bye’</p><p>全部结束!</p><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于笔者水平有限, 如果解释有误, 还望指出 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f604.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>通过整理, 笔者发现绝大部分题目都是因为自己对于基础知识或者说某个 API 的参数理解偏差才做错的.</p><p>笔者的重灾区在原型那一块, 所以这次被虐和整理还是很有意义呀.</p><p>笔者相信 坚实的基础是深入编程的前提. 所以基础书还是要常看啊 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f439.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>最后这些变态题现在看看还变态嘛?</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猜数字游戏算法</title>
      <link href="/2018/03/16/%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/03/16/%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a name="5f5f8ea7"></a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有猜数字游戏如下</p><blockquote><p>庄家预先写下一个四位数字（每位数字各不相同），玩家每次随机猜一个数字，庄家告知玩家猜对了几A几B（A代表数字和位置都相同，B代表包含该数字但位置不同，比如如果庄家写的是3514，玩家猜的是3165，庄家会回答1A2B），玩家继续猜，直到猜中为止。如果超过5轮没猜中，则玩家输，否则玩家赢。请为玩家设计一个猜数字的算法，确保玩家能够大概率胜。<br><br>例如：庄家写下9876，玩家第一次猜0123，庄家回复0A0B；玩家继续猜4567，庄家恢复0A2B；依次下去，知道玩家猜中9876为止。</p></blockquote><a id="more"></a><p>一道很有意思的题目，网上搜索下，发现有很多解法，主流两种</p><ol><li>筛选法</li><li>信息熵法</li></ol><p><a name="63ae59cd"></a></p><h2 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h2><p>筛选法原理很简单，首先我们需要知道庄家所有可能结果的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>*<span class="number">9</span>*<span class="number">8</span>*<span class="number">7</span> === <span class="number">5040</span>  <span class="comment">// 总共有5040个可能结果</span></span><br></pre></td></tr></table></figure><p>然后，玩家猜一个数字，和庄家数字对比后得到一个反馈结果<code>某A某B</code></p><p>这时候，我们把所有5040个可能的结果和玩家数字对比，再从中过滤出和<code>某A某B</code>一样反馈的结果集，那么这个<strong>结果集中一定包含了庄家数字</strong>，这就是一次过滤，排除很多无关的数据。</p><p>然后在第一次过滤出来的结果集中随机取一个数字，用这个数字和庄家对比进行第二次猜测，用上面的方法在上一次的过滤结果中再次过滤，得到第二次过滤结果。</p><p>循环过滤，最后只剩一个结果。</p><p><a name="a22fc877"></a></p><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p>首先是得到所有可能数字的集合，本质上是0-9999之间每位不重复的数字集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [] <span class="comment">// 集合数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> str</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">        str = <span class="string">'0'</span> + i <span class="comment">// 例子： 0987 这种特殊情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = <span class="string">''</span> + i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Set</span>(arr).size !== <span class="number">4</span>) <span class="keyword">continue</span> <span class="comment">// 判断size === 4，表示没有重复数字</span></span><br><span class="line">    data.push(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure><p>两串数字对比并得到反馈的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analyse</span>(<span class="params">basicArr, compareArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    basicArr.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == compareArr[index]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> A = count</span><br><span class="line">    <span class="keyword">const</span> B = (compareArr.length + basicArr.length) - <span class="keyword">new</span> <span class="built_in">Set</span>([...basicArr, ...compareArr]).size - A</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`A<span class="subst">$&#123;A&#125;</span>B<span class="subst">$&#123;B&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    analyse([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>])  <span class="comment">// A1B1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>过滤函数那部分就简单了，略。</p><p>整体代码如下，大概率在第五次过滤就只有一个结果存在了，少部分在5次前就出来了，部分需要更多次过滤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数用于分析两个数组之间的反馈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analyse</span>(<span class="params">basicArr, compareArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    basicArr.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == compareArr[index]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> A = count</span><br><span class="line">    <span class="keyword">const</span> B = (compareArr.length + basicArr.length) - <span class="keyword">new</span> <span class="built_in">Set</span>([...basicArr, ...compareArr]).size - A</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`A<span class="subst">$&#123;A&#125;</span>B<span class="subst">$&#123;B&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认以结果集第一个数据为猜测值, 最后根据猜测反馈的值过滤出所有符合反馈的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">preResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> guess = preResult[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> re = analyse(store, guess)</span><br><span class="line">    <span class="keyword">const</span> filterResult = preResult.filter(<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (analyse(guess, arr) == re) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> filterResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="keyword">let</span> data = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下for循环用来将符合猜规则的数据存放到data变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> str</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">        str = <span class="string">'0'</span> + i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = <span class="string">''</span> + i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Set</span>(arr).size !== <span class="number">4</span>) <span class="keyword">continue</span></span><br><span class="line">    data.push(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成庄家数组</span></span><br><span class="line"><span class="keyword">const</span> store = data[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * data.length) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'庄家数据: '</span>, store)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下每一次filter包含一次猜测,返回可能的结果集,在结果集中重复过滤,大概率会在第五次猜测后得到唯一的数据, 第六次概率更高</span></span><br><span class="line"><span class="keyword">const</span> filterResult1 = filter(data)</span><br><span class="line"><span class="keyword">const</span> filterResult2 = filter(filterResult1)</span><br><span class="line"><span class="keyword">const</span> filterResult3 = filter(filterResult2)</span><br><span class="line"><span class="keyword">const</span> filterResult4 = filter(filterResult3)</span><br><span class="line"><span class="keyword">const</span> filterResult5 = filter(filterResult4)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterResult5)</span><br></pre></td></tr></table></figure><p><a name="895b4ac6"></a></p><h2 id="信息熵法"><a href="#信息熵法" class="headerlink" title="信息熵法"></a>信息熵法</h2><p>待以后有空补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于原型链</title>
      <link href="/2018/03/14/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/03/14/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><a name="9f4eb5bf"></a></p><h2 id="以下这张图，基本解释了所有的原型关系"><a href="#以下这张图，基本解释了所有的原型关系" class="headerlink" title="以下这张图，基本解释了所有的原型关系"></a>以下这张图，基本解释了所有的原型关系</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/280778/1551716465866-8a074836-eba5-48e8-9289-f961b243f2b1.png#align=left&display=inline&height=586&name=image.png&originHeight=586&originWidth=520&size=173051&status=done&width=520" alt="image.png"></p><p>核心要素是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line">foo.__proto__ == foo.constructor.prototype == Foo.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// .__proto__ 可以简单理解成 .construstor.prototype 的简写</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>但本质上<code>__proto__</code>不等于<code>.constructor.prototype</code>，当我把对象的<code>constructor</code>置为<code>null</code>，<code>.__proto__</code>还是能够读到，但是<code>.constructor.prototype</code>直接报错了。这里这么说只是为了方便理解<br><br>说到底<code>.__proto__</code>就是这个对象的构造函数的原型。</p><p>理解了这个就能理解上面图示的所有的关系了。</p><hr><p><a name="b13987ed"></a></p><h2 id="以下有助于理解几个基类之间的关系"><a href="#以下有助于理解几个基类之间的关系" class="headerlink" title="以下有助于理解几个基类之间的关系"></a>以下有助于理解几个基类之间的关系</h2><p><code>instanceof</code>操作符</p><p>instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设 L instanceof R </span><br><span class="line">//通过判断</span><br><span class="line"> L.__proto__.__proto__ ..... === R.prototype ？</span><br><span class="line"> //最终返回true or false</span><br></pre></td></tr></table></figure><p>也就是沿着L的<code>__proto__</code>一直寻找到原型链末端，直到等于<code>R.prototype</code>为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function instanceof Object // true </span><br><span class="line"> Object instanceof Function // true </span><br><span class="line"> Function instanceof Function //true</span><br><span class="line"> Object instanceof Object // true</span><br><span class="line"> Number instanceof Number //false</span><br></pre></td></tr></table></figure><p><a name="30bacd56"></a></p><h2 id="总结了下"><a href="#总结了下" class="headerlink" title="总结了下"></a>总结了下</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.constructor === <span class="function"><span class="keyword">function</span> <span class="title">Function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor === <span class="function"><span class="keyword">function</span> <span class="title">Function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个需要特殊注意一下， 记住这个基本上能把所有的东西都推理出来了。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype === functoin ()&#123; native code &#125; <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor === Funtion <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor.prototype === <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; native code &#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...无限循环</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// 原型链的终点</span></span><br></pre></td></tr></table></figure><p><a name="68d14dba"></a></p><h2 id="关于-proto"><a href="#关于-proto" class="headerlink" title="关于__proto__"></a>关于<code>__proto__</code></h2><p><code>__proto__</code> 是内部的<strong>构造函数原型对象</strong>， 一般情况下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === obj.constructor.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是<code>__proto__</code>不会因为你在对象的prototype中更改constructor而改变。它总是指向对象被创建时的那个<code>constructor</code> function ， 举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog; <span class="comment">// 在继承的时候，这里改变了prototype.constructor，但是不影响__proto__的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog() <span class="keyword">instanceof</span> Animal <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Dog() <span class="keyword">instanceof</span> Dog <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据以上 instanceof 的原理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.__proto__ === Animal.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里__proto__和constructor.prototype的结果就不同, 一定要搞清楚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.constructor.prototype ===  Animal.prototype <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.constructor.prototype === Dog.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>部分内容摘自<br><br>作者：苏墨橘<br><br>链接：<a href="https://www.zhihu.com/question/34183746/answer/59043879" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746/answer/59043879</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
