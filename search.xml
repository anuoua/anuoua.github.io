<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vscode远程开发的代理配置</title>
      <link href="/2020/02/28/vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/02/28/vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>去年vscode就支持了远程开发，通过ssh连接到服务器，就像在本地写代码一样，实在是太爽了。</p><p>但是有一个问题是，vscode的ssh无法通过代理访问，官方文档上的方法需要一台<code>跳板机</code>来完成。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jump box with public IP address</span></span><br><span class="line">Host jump-box</span><br><span class="line">    HostName 52.179.157.97</span><br><span class="line">    User sana</span><br><span class="line">    IdentityFile ~/.ssh/jumpbox</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target machine with private IP address</span></span><br><span class="line">Host target-box</span><br><span class="line">    HostName &lt;IP address of target&gt;</span><br><span class="line">    User sana</span><br><span class="line">    IdentityFile ~/.ssh/target</span><br><span class="line">    ProxyCommand ssh -q -W %h:%p jump-box</span><br></pre></td></tr></table></figure><a id="more"></a><p>详见：<a href="https://code.visualstudio.com/blogs/2019/10/03/remote-ssh-tips-and-tricks" target="_blank" rel="noopener">remote-ssh-tips-and-tricks</a></p><p>但是这样太不方便了，两台服务器，配置过于复杂了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>可以通过git自带的connect.exe来完成，可以在git安装目录中找到这个exe文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host xxx.xxx.xxx.xxx</span><br><span class="line">  HostName xxx.xxx.xxx.xxx</span><br><span class="line">  User root</span><br><span class="line">  ProxyCommand C:\Program Files\Git\mingw64\bin\connect.exe -H 127.0.0.1:1081 %h %p</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>vscode常规代理配置方法，是在运行时需要通过命令行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vscode --proxy-server=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自建KMS服务</title>
      <link href="/2019/12/19/%E8%87%AA%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/12/19/%E8%87%AA%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="自建KMS服务"><a href="#自建KMS服务" class="headerlink" title="自建KMS服务"></a>自建KMS服务</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>项目地址：<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">Wind4/vlmcsd</a></p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>为了避免系统环境不同引发未知问题，在这里使用 Docker。<br>Ubuntu 安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>CentOS 安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装-vlmscd"><a href="#安装-vlmscd" class="headerlink" title="安装 vlmscd"></a>安装 vlmscd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mikolatero/vlmcsd</span><br><span class="line">docker run -d -p 1688:1688 --restart=always --name="vlmcsd" mikolatero/vlmcsd</span><br></pre></td></tr></table></figure><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>需要打开 1688 端口供 vlmcsd 使用。在这里举两个常用的。</p><h4 id="UFW"><a href="#UFW" class="headerlink" title="UFW"></a>UFW</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 1688</span><br></pre></td></tr></table></figure><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 1688 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 1688 -j ACCEPT</span><br></pre></td></tr></table></figure><p>完！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows &amp; Office KMS激活</title>
      <link href="/2019/12/19/Windows%20&amp;%20Office%20KMS%E6%BF%80%E6%B4%BB/"/>
      <url>/2019/12/19/Windows%20&amp;%20Office%20KMS%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-amp-Office-KMS激活"><a href="#Windows-amp-Office-KMS激活" class="headerlink" title="Windows &amp; Office KMS激活"></a>Windows &amp; Office KMS激活</h1><h2 id="Windows激活"><a href="#Windows激活" class="headerlink" title="Windows激活"></a>Windows激活</h2><p>设置kms服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br></pre></td></tr></table></figure><p>通过kms激活</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure><p>如果系统不是VL版本，也可以通过，重新安装GVLK KEY变成VL版。（文章最下面查找GVLK）<br>查找自己的系统版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic os get caption</span><br></pre></td></tr></table></figure><a id="more"></a><p>安装KEY</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx</span><br></pre></td></tr></table></figure><h2 id="激活Office"><a href="#激活Office" class="headerlink" title="激活Office"></a>激活Office</h2><p>找到office安装目录，比如 <code>C:\Program Files (x86)\Microsoft Office\Office16</code><br>64位的就是<code>C:\Program Files\Microsoft Office\Office16</code><br>office16是office2016，office15就是2013，office14就是2010.<br>然后目录对的话，该目录下面应该有个<code>OSPP.VBS</code>。<br>接下来就cd到这个目录下面，例如（请更改为实际安装目录）：<br>找到目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd "C:\Program Files (x86)\Microsoft Office\Office16"</span><br></pre></td></tr></table></figure><p>设置kms服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript ospp.vbs /sethst:kms.03k.org</span><br></pre></td></tr></table></figure><p>激活office</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript ospp.vbs /act</span><br></pre></td></tr></table></figure><h2 id="GVLK-KEY查询"><a href="#GVLK-KEY查询" class="headerlink" title="GVLK KEY查询"></a>GVLK KEY查询</h2><blockquote><p>office2016 <a href="https://technet.microsoft.com/zh-cn/library/dn385360(v=office.16).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/library/dn385360(v=office.16).aspx</a></p><p>office2013 <a href="https://technet.microsoft.com/ZH-CN/library/dn385360.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/ZH-CN/library/dn385360.aspx</a></p><p>office2010 <a href="https://technet.microsoft.com/ZH-CN/library/ee624355(v=office.14).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/ZH-CN/library/ee624355(v=office.14).aspx</a></p><p>Server/Windows <a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置Powershell命令行代理</title>
      <link href="/2019/08/11/%E9%85%8D%E7%BD%AEPowershell%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2019/08/11/%E9%85%8D%E7%BD%AEPowershell%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在日常windows环境开发中，powershell经常需要用到代理，但是每次去系统变量中配置环境变量还是显得过于麻烦了，所以我们可以定义两个命令：</p><ul><li>应用代理环境变量</li><li>取消代理环境变量</li></ul><p>直接在powershell中调用这两命令就方便很多了。</p><h2 id="Powershell基本概念"><a href="#Powershell基本概念" class="headerlink" title="Powershell基本概念"></a>Powershell基本概念</h2><p>Powershell中不像bash那样所有东西都是字符串，它支持对象，比如环境变量是存放在Env对象中的，添加和移除环境变量都是操作Env这个对象。</p><a id="more"></a><p>操作对象的方式（以环境变量为例）：</p><ul><li>添加/修改一个键值对：<code>Set-Item Env:http_proxy = &quot;http://127.0.0.1:1080&quot;</code></li><li>移除一个键值对：<code>Remove-Item Env:http_proxy</code></li></ul><p>知道这个就能配置代理了。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>我们需要将这两个命令写入powershell启动脚本（类似linux的<code>.bashrc</code>），windows启动脚本在哪儿？<a href="/2019/08/11/Powershell启动脚本/" title="点击这里">点击这里</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_proxy_variable</span></span> &#123;</span><br><span class="line"><span class="built_in">Set-Item</span> Env:http_proxy <span class="string">"http://127.0.0.1:1080"</span>  <span class="comment"># 代理地址</span></span><br><span class="line"><span class="built_in">Set-Item</span> Env:https_proxy <span class="string">"http://127.0.0.1:1080"</span> <span class="comment"># 代理地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unset_proxy_variable</span></span> &#123;</span><br><span class="line">    <span class="built_in">Remove-Item</span> Env:http_proxy</span><br><span class="line">    <span class="built_in">Remove-Item</span> Env:https_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> spp <span class="literal">-Value</span> set_proxy_variable</span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> upp <span class="literal">-Value</span> unset_proxy_variable</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>如果打开新的poewrshell窗口报<code>此系统上禁止运行脚本</code>错误，需要设置运行策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><code>spp</code> 启用代理</li><li><code>upp</code> 取消代理</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Powershell启动脚本</title>
      <link href="/2019/08/11/Powershell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/08/11/Powershell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>Linux中bash有一个启动的默认配置文件：<code>.bashrc</code>或者<code>.bash_profile</code>，自定义命令以及预配置可以写在那里，但是windows的配置文件在哪里呢？</p><p>按照微软官网的说法是按照以下的对应关系，但是实际上是不对的。</p><table><thead><tr><th align="left">Description</th><th align="left">Path</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PsHome\Profile.ps1</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PsHome\Microsoft.PowerShell_profile.ps1</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$Home\[My ]Documents\PowerShell\Profile.ps1</code></td></tr><tr><td align="left">Current user, Current Host</td><td align="left"><code>$Home\[My ]Documents\PowerShell\ Microsoft.PowerShell_profile.ps1</code></td></tr></tbody></table><a id="more"></a><p>我们可以通过环境变量查看配置文件的路径</p><table><thead><tr><th align="left">Description</th><th align="left">Name</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PROFILE.AllUsersAllHosts</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PROFILE.AllUsersCurrentHost</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$PROFILE.CurrentUserAllHosts</code></td></tr><tr><td align="left">Current User, Current Host</td><td align="left"><code>$PROFILE</code> or <code>$PROFILE.CurrentUserCurrentHost</code></td></tr></tbody></table><p>windows 10 1903版本上的配置文件的实际路径</p><table><thead><tr><th align="left">Description</th><th align="left">Path</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PsHome\profile.ps1</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PsHome\Microsoft.PowerShell_profile.ps1</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$Home\Documents\WindowsPowerShell\profile.ps1</code></td></tr><tr><td align="left">Current user, Current Host</td><td align="left"><code>$Home\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></td></tr></tbody></table><p>然后就是按照路径创建配置文件，终于可以写点自定义命令了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 18.04开启bbr</title>
      <link href="/2019/03/04/ubuntu%2018.04%E5%BC%80%E5%90%AFbbr/"/>
      <url>/2019/03/04/ubuntu%2018.04%E5%BC%80%E5%90%AFbbr/</url>
      
        <content type="html"><![CDATA[<p><strong>说明：</strong><code>Ubuntu 18.04</code>前几天发布了，改变挺大的，内核也直接升到了正式版<code>4.15</code>，而<code>BBR</code>内核要求为<code>4.9</code>，也就是说满足了，所以我们不需要换内核就可以很快的开启<code>BBR</code>，这里简单说下方法。<br><a name="ea340b9d"></a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1、修改系统变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、保存生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>3、查看内核是否已开启BBR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>显示以下即已开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_available_congestion_control</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure><p>4、查看BBR是否启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>显示以下即启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsmod | grep bbr</span></span><br><span class="line">tcp_bbr                20480  14</span><br></pre></td></tr></table></figure><p><a href="https://www.moerats.com/archives/612/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xshell调整tmux大小无效问题</title>
      <link href="/2019/03/04/Xshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/04/Xshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>由screen转tmux，使用的时候发现tmux的pane大小只能左右调节不能上下调节，各种搜索后发现是xshell的问题，<strong>xshell</strong>这个坑竟然不响应ctrl+up和ctrl+down。。。 两个组合键输出的特殊字符是<code>[1;5A</code>和<code>[1;5B</code>，其中``是一个代表<code>esc</code>的特殊字符。复制输出的字符串，xshell工具-&gt;选项-&gt;键盘和鼠标-&gt;编辑-&gt;新建，按ctrl+up，类型选择发送字符串，粘贴刚才复制的对应字符串，完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tmux常用命令以及快捷键</title>
      <link href="/2019/03/04/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><a name="dbb0d3bb"></a></p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><table><thead><tr><th align="left">tmux new[-session] -s $session_name -d</th><th align="left">新建会话(-d 是否在后台)</th></tr></thead><tbody><tr><td align="left">tmux new -s name -n $window_name</td><td align="left">新建会话及窗口</td></tr><tr><td align="left">tmux at[tach] -t session</td><td align="left">重新连接(-t 后接会话名称)</td></tr><tr><td align="left">tmux ls</td><td align="left">显示保存的会话</td></tr><tr><td align="left">tmux kill-session -t $session_name</td><td align="left">删除会话</td></tr></tbody></table><a id="more"></a><p><a name="887aaa1f"></a></p><h2 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prefix: ctrl+b</span><br><span class="line"></span><br><span class="line">prefix `&#123; / &#125;` 左右pane交换</span><br><span class="line">prefix `&quot;`: 上下分割</span><br><span class="line">prefix `%`: 左右分割</span><br><span class="line">prefix `方向键`: focus到相应的panel上</span><br><span class="line">prefix `o`: focus 到下一个pannel上 </span><br><span class="line">prefix `d`: 推出并保存工作区  `tmux attach` 恢复</span><br><span class="line">prefix `&amp;`: 关闭工作区，无法保存</span><br><span class="line">prefix `:kill-session`: 关闭当前session</span><br><span class="line">prefix `d`: 临时退出session</span><br><span class="line">prefix `:kill-server`: 关闭所有session</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NERD tree 配置命令以及快捷键</title>
      <link href="/2019/03/04/NERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/NERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><a name="57fc581c"></a></p><h2 id="NERD-tree-配置"><a href="#NERD-tree-配置" class="headerlink" title="NERD tree 配置"></a>NERD tree 配置</h2><p>使用F2快速展开或隐藏它打开vim时自动展开NERDTree</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd vimenter * <span class="keyword">if</span> !argc() | NERDTree | endif</span><br></pre></td></tr></table></figure><p>如果窗口除了NERDTree没有其他文件时，自动关闭，可以减少多次按:q</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd bufenter * <span class="keyword">if</span> (winnr(<span class="string">"$"</span>) == 1 &amp;&amp; exists(<span class="string">"b:NERDTreeType"</span>) &amp;&amp; b:NERDTreeType == <span class="string">"primary"</span>) | q | endif</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用F2快速展开或隐藏它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><p><a name="ddf7d2a5"></a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br></pre></td></tr></table></figure><p><a name="f7d29966"></a></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">shift + a   侧边栏宽度放大，再按一下恢复</span><br><span class="line"></span><br><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br><span class="line"></span><br><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><p><a name="d41d8cd9"></a></p><p>## </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim常用快捷键</title>
      <link href="/2019/03/04/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/04/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">v：按字符选择。经常使用的模式，所以亲自尝试一下它。</span><br><span class="line"></span><br><span class="line">V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。</span><br><span class="line"></span><br><span class="line">一、移动光标</span><br><span class="line">1、左移h、右移l、下移j、上移k</span><br><span class="line">2、向下翻页ctrl + f，向上翻页ctrl + b</span><br><span class="line">3、向下翻半页ctrl + d，向上翻半页ctrl + u</span><br><span class="line">4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</span><br><span class="line">5、移动光标到下一个句子 ），移动光标到上一个句子（</span><br><span class="line">6、移动到段首&#123;，移动到段尾&#125;</span><br><span class="line">7、移动到下一个词w，移动到上一个词b</span><br><span class="line">8、移动到文档开始gg，移动到文档结束G</span><br><span class="line">9、移动到匹配的&#123;&#125;.().[]处%</span><br><span class="line">10、跳到第n行 ngg 或 nG 或 :n</span><br><span class="line">11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</span><br><span class="line">12、读取当前字符，并移动到本屏幕内下一次出现的地方 *</span><br><span class="line">13、读取当前字符，并移动到本屏幕内上一次出现的地方 #</span><br><span class="line"></span><br><span class="line">二、查找替换</span><br><span class="line">1、光标向后查找关键字 #或者g#</span><br><span class="line">2、光标向前查找关键字 *或者g*</span><br><span class="line">3、当前行查找字符 fx, Fx, tx, Tx</span><br><span class="line">4、基本替换 :s/s1/s2 （将下一个s1替换为s2）</span><br><span class="line">5、全部替换 :%s/s1/s2</span><br><span class="line">6、只替换当前行 :s/s1/s2/g</span><br><span class="line">7、替换某些行 :n1,n2 s/s1/s2/g</span><br><span class="line">8、搜索模式为 /string，搜索下一处为n，搜索上一处为N</span><br><span class="line">9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母</span><br><span class="line">10、移动到某标签处 `x，1旁边的键</span><br><span class="line">11、移动到上次编辑文件的位置 `.</span><br><span class="line"></span><br><span class="line">PS：.代表一个任意字符 *代表一个或多个字符的重复</span><br><span class="line">         正则表达式的内容将会在后续文章中整理</span><br><span class="line"></span><br><span class="line">三、编辑操作</span><br><span class="line">1、光标后插入a, 行尾插入A</span><br><span class="line">2、后插一行插入o，前插一行插入O</span><br><span class="line">3、删除字符插入s， 删除正行插入S</span><br><span class="line">4、光标前插入i，行首插入I</span><br><span class="line">5、删除一行dd，删除后进入插入模式cc或者S</span><br><span class="line">6、删除一个单词dw，删除一个单词进入插入模式cw</span><br><span class="line">7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</span><br><span class="line">8、粘贴p，交换两个字符xp，交换两行ddp</span><br><span class="line">9、复制y，复制一行yy</span><br><span class="line">10、撤销u，重做ctrl + r，重复.</span><br><span class="line">11、智能提示 ctrl + n 或者 ctrl + p</span><br><span class="line">12、删除motion跨过的字符，删除并进入插入模式 c&#123;motion&#125;</span><br><span class="line">13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</span><br><span class="line">14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</span><br><span class="line">15、删除motion跨过的字符，删除但不进入插入模式 d&#123;motion&#125;</span><br><span class="line">16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</span><br><span class="line">17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx</span><br><span class="line">18、如果只是复制的情况时，将12-17条中的c或d改为y</span><br><span class="line">19、删除到行尾可以使用D或C</span><br><span class="line">20、拷贝当前行 yy或者Y</span><br><span class="line">21、删除当前字符 x</span><br><span class="line">22、粘贴 p</span><br><span class="line">23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</span><br><span class="line">24、重复执行上一个作用使用.</span><br><span class="line">25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</span><br><span class="line">26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</span><br><span class="line">27、 &gt;&gt; 缩进所有选择的代码</span><br><span class="line">28、 &lt;&lt; 反缩进所有选择的代码</span><br><span class="line">29、gd 移动到光标所处的函数或变量的定义处</span><br><span class="line">30、K 在man里搜索光标所在的词</span><br><span class="line">31、合并两行 J</span><br><span class="line">32、若不想保存文件，而重新打开 :e!</span><br><span class="line">33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</span><br><span class="line"></span><br><span class="line">四、窗口操作</span><br><span class="line">1、分隔一个窗口:split或者:vsplit</span><br><span class="line">2、创建一个窗口:new或者:vnew</span><br><span class="line">3、在新窗口打开文件:sf &#123;filename&#125;</span><br><span class="line">4、关闭当前窗口:close</span><br><span class="line">5、仅保留当前窗口:only</span><br><span class="line">6、到左边窗口 ctrl + w, h</span><br><span class="line">7、到右边窗口 ctrl + w, l</span><br><span class="line">8、到上边窗口 ctrl + w, k</span><br><span class="line">9、到下边窗口 ctrl + w, j</span><br><span class="line">10、到顶部窗口 ctrl + w, t</span><br><span class="line">11、到底部窗口 ctrl + w, b</span><br><span class="line"></span><br><span class="line">五、宏操作</span><br><span class="line">1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</span><br><span class="line">2、@[a-z]执行寄存器[a-z]中的操作</span><br><span class="line">3、@@执行最近一次记录的宏操作</span><br><span class="line"></span><br><span class="line">六、可视操作</span><br><span class="line">1、进入块可视模式 ctrl + v</span><br><span class="line">2、进入字符可视模式 v</span><br><span class="line">3、进入行可视模式 V</span><br><span class="line">4、删除选定的块 d</span><br><span class="line">5、删除选定的块然后进入插入模式 c</span><br><span class="line">6、在选中的块同是插入相同的字符 I&lt;String&gt;ESC</span><br><span class="line"></span><br><span class="line">七、跳到声明</span><br><span class="line">1、[[ 向前跳到顶格第一个&#123;  </span><br><span class="line">2、[] 向前跳到顶格第一个&#125;</span><br><span class="line">3、]] 向后跳到顶格的第一个&#123;</span><br><span class="line">4、]] 向后跳到顶格的第一个&#125;</span><br><span class="line">5、[&#123; 跳到本代码块的开头</span><br><span class="line">6、]&#125; 跳到本代码块的结尾</span><br><span class="line"></span><br><span class="line">八、挂起操作</span><br><span class="line">1、挂起Vim ctrl + z 或者 :suspend</span><br><span class="line">2、查看任务 在shell中输入 jobs</span><br><span class="line">3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</span><br><span class="line">4、执行shell命令 :!command</span><br><span class="line">5、开启shell命令 :shell，退出该shell exit</span><br><span class="line">6、保存vim状态 :mksession name.vim</span><br><span class="line">7、恢复vim状态 :source name.vim</span><br><span class="line">8、启动vim时恢复状态 vim -S name.vim</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux无损调整分区大小</title>
      <link href="/2019/03/04/Linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
      <url>/2019/03/04/Linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p><a name="c931653c"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>500G 硬盘</p><pre><code>100MB `boot`分区 |8G `swap`分区 |450G `/`分区</code></pre><p>我需要将<code>/home</code>分区单独提取一个分区出来，即变成</p><pre><code>100MB `boot`分区 |8G `swap`分区 |100G `/`分区 |350G `/home`分区</code></pre><p><a name="52b36576"></a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>sudo e2fsck -fy /dev/sda3 // f 是表示检查，y表示一直确认，直到修复完</li><li>sudo resize2fs /dev/sda3 100G  //将文件系统调整到50G（不太明白文件系统大小和分区大小的关系）</li><li>sudo fdisk /dev/sda  // 使用fdisk进行分区</li><li>首先输入p，查看要调整分区（sda3）的start序号（重要）</li><li>输入 <code>d</code> 删除要sda3，选择3</li><li>输入 <code>n</code> 添加一个主分区，分区号选择3</li><li>选择<code>start</code>地址，就是刚才查看的地址（一般不用修改，默认就是刚才的值）</li><li>选择分区容量，输入<code>+100G</code></li><li>然后再新建一个分区，输入n，选择p（主分区），选择默认起点，再选择默认终点</li><li>按w保存分区表<ol><li>这里有可能会报错，什么device被占用之类的错误</li><li>使用 <code>partprobe /dev/sda</code>命令重载/dev/sda 重载分区表，（命令成功界面没有显示）</li></ol></li><li><code>sudo e2fsck -fy /dev/sda3</code> 修复sda3分区</li><li><code>sudo resize2fs /dev/sda3</code> 检查一下有没有问题</li><li>sda3分区已经没有问题了，数据全部都保留着。</li><li>格式化sda4 <code>sudo mkfs.ext4 /dev/sda4</code></li><li>然后就是迁移所有<code>/home</code>数据到<code>sda4</code></li><li>在fstab中添加一行  <code>UUID=xxxxxxxxxxxxxxx /home ext4 defaults 0 0</code></li><li>开机后使用<code>sudo chown -R username:username /home/fan</code>，否则由于权限问题导致无法登录</li></ol><a id="more"></a><p>大功告成！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux创建开机启动服务</title>
      <link href="/2019/03/04/Linux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/03/04/Linux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><a name="e6cefb85"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>使用linux离不开ss，每次都需要手动输入命令开启，很麻烦，所以需要创建开机就启动的服务。<br><a name="a62d8a1a"></a></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>假设我们有一段需要开机启动的服务脚本<code>/home/username/document/ss-local.sh</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-local -c /home/username/document/ssconfig.json</span><br></pre></td></tr></table></figure><a id="more"></a><p><a name="c010aa73"></a></p><h2 id="创建服务（两种方式）"><a href="#创建服务（两种方式）" class="headerlink" title="创建服务（两种方式）"></a>创建服务（两种方式）</h2><p><a name="b3ffe560"></a></p><h3 id="1-创建成系统服务"><a href="#1-创建成系统服务" class="headerlink" title="1. 创建成系统服务"></a>1. 创建成系统服务</h3><p>然后在<code>/etc/init.d/</code>新建<code>ss-local</code>文件，注意这个文件的写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"><span class="meta">#</span>## BEGIN INIT INFO</span><br><span class="line"><span class="meta">#</span> Provides:          ss-local // 名字要和文件名一样</span><br><span class="line"><span class="meta">#</span> Required-Start:    $remote_fs</span><br><span class="line"><span class="meta">#</span> Required-Stop:     $remote_fs</span><br><span class="line"><span class="meta">#</span> Default-Start:    2 3 4 5 </span><br><span class="line"><span class="meta">#</span> Default-Stop:     0 1 6</span><br><span class="line"><span class="meta">#</span> Short-Description: local shadowsocks service</span><br><span class="line"><span class="meta">#</span>## END INIT INFO</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line">NAME=ss-local</span><br><span class="line">DEAMON=/home/username/document/ss-local.sh  # 注意设置正确的脚本路径</span><br><span class="line"></span><br><span class="line">start_sslocal() &#123;</span><br><span class="line">    start-stop-daemon --start --background --name $NAME --exec $DEAMON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_sslocal() &#123;</span><br><span class="line">    start-stop-daemon --stop --name $NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case "$1" in  </span><br><span class="line">  start|"")</span><br><span class="line">        start_sslocal</span><br><span class="line">        ;;  </span><br><span class="line">  restart|reload|force-reload)</span><br><span class="line">        stop_sslocal</span><br><span class="line">        ;;  </span><br><span class="line">  stop)</span><br><span class="line">        exit 0 </span><br><span class="line">        ;;  </span><br><span class="line">  *)  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>将文件的权限置为755</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 ss-local</span><br></pre></td></tr></table></figure><p>将服务文件设置为开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d ss-local defaults</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ss-local</span><br></pre></td></tr></table></figure><p><a name="f82206a2"></a></p><h3 id="2-创建成systemd服务"><a href="#2-创建成systemd服务" class="headerlink" title="2. 创建成systemd服务"></a>2. 创建成systemd服务</h3><p>定位到<code>/usr/lib/systemd/system</code>目录（如果没有就新建），新建ss-local.service。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="meta">#</span>定义描述</span><br><span class="line">Description=The ss-local service</span><br><span class="line"><span class="meta">#</span>指定了在systemd在执行完那些target之后再启动该服务</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span>定义Service 的运行type，一般是forking，就是后台运行</span><br><span class="line">Type=simple</span><br><span class="line"><span class="meta">#</span>以下定义systemctl start |stop |reload *.service  的每个执行方法，具体命令#需要&gt;写绝对路径</span><br><span class="line">ExecStart=/home/fan/Documents/ss/ss-local.sh</span><br><span class="line"><span class="meta">#</span>创建私有的内存临时空间</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后就可以设置开机启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开机启动</span><br><span class="line">sudo systemctl enable ss-local.service</span><br><span class="line"><span class="meta">#</span> 启动服务</span><br><span class="line">sudo systemctl start ss-local.service</span><br></pre></td></tr></table></figure><p>完</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript变态题</title>
      <link href="/2018/03/22/javascript%E5%8F%98%E6%80%81%E9%A2%98/"/>
      <url>/2018/03/22/javascript%E5%8F%98%E6%80%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>原帖： <a href="https://github.com/xiaoyu2er/blog/issues/1" target="_blank" rel="noopener">https://github.com/xiaoyu2er/blog/issues/1</a><br><br>原题来自: <a href="http://javascript-puzzlers.herokuapp.com/" target="_blank" rel="noopener">javascript-puzzlers</a></p><p>读者可以先去做一下感受感受. 当初笔者的成绩是 21/44…</p><p>当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了….</p><p>不过, 对于基础知识的理解是深入编程的前提. 让我们一起来看看这些变态题到底变态不变态吧!</p><a id="more"></a><p><a name="6e32403c"></a></p><h2 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Array/map</li><li>Number/parseInt</li><li>Global_Objects/parseInt</li><li>JavaScript parseInt</li></ul><p>首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值</p><p>其中回调函数接受三个参数 currentValue, index, arrary;</p><p>而题目中, map只传入了回调函数–parseInt.</p><p>其次, parseInt 只接受两个两个参数 string, radix(基数).</p><p>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：</p><p>如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).<br><br>如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。<br><br>如果字符串 string 以其它任何值开头，则基数是10 (十进制)。<br><br>所以本题即问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0);</span><br><span class="line">parseInt(&apos;2&apos;, 1);</span><br><span class="line">parseInt(&apos;3&apos;, 2);</span><br></pre></td></tr></table></figure><p>首先后两者参数不合法.</p><p>所以答案是 [1, NaN, NaN]</p><p><a name="6455193a"></a></p><h2 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Operators/typeof</li><li>Operators/instanceof</li><li>Operators/instanceof(中)</li></ul><p>typeof 返回一个表示类型的字符串.</p><p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p><p>这个题可以直接看链接… 因为 typeof null === ‘object’ 自语言之初就是这样….</p><p>typeof 的结果请看下表:</p><table><thead><tr><th>type</th><th align="center">result</th></tr></thead><tbody><tr><td>Undefined</td><td align="center">“undefined”</td></tr><tr><td>Null</td><td align="center">“object”</td></tr><tr><td>Boolean</td><td align="center">“boolean”</td></tr><tr><td>Number</td><td align="center">“number”</td></tr><tr><td>String</td><td align="center">“string”</td></tr><tr><td>Symbol</td><td align="center">“symbol”</td></tr><tr><td>Host object</td><td align="center">Implementation-dependent</td></tr><tr><td>Function</td><td align="center">“function”</td></tr><tr><td>Object</td><td align="center">“object”</td></tr></tbody></table><p>所以答案 [object, false]</p><p><a name="62d27b2f"></a></p><h2 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Array/Reduce</li><li>arr.reduce(callback[, initialValue])</li></ul><p>reduce接受两个参数, 一个回调, 一个初始值.</p><p>回调函数接受四个参数 previousValue, currentValue, currentIndex, array</p><p>需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.</p><p>所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</p><p>答案 an error</p><p><a name="146b01ec"></a></p><h2 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var val = &apos;smtg&apos;;</span><br><span class="line">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Operators/Operator_Precedence</li><li>Operators/Conditional_Operator</li></ul><p>简而言之 + 的优先级 大于 ?</p><p>所以原题等价于 ‘Value is true’ ? ‘Somthing’ : ‘Nonthing’ 而不是 ‘Value is’ + (true ? ‘Something’ : ‘Nonthing’)</p><p>答案 ‘Something’</p><p><a name="572d97b6"></a></p><h2 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        var name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这个相对简单, 一个知识点:</p><p>Hoisting<br><br>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</p><p>这个题目相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var name;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>所以答案是 ‘Goodbye Jack’</p><p><a name="66956306"></a></p><h2 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var END = Math.pow(2, 53);</span><br><span class="line">var START = END - 100;</span><br><span class="line">var count = 0;</span><br><span class="line">for (var i = START; i &lt;= END; i++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">console.log(count);</span><br></pre></td></tr></table></figure><p>一个知识点:</p><p>Infinity<br><br>在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.</p><p>js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。<br><br>2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。<br><br>9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。</p><p><a name="628ffa72"></a></p><h2 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary = [0,1,2];</span><br><span class="line">ary[10] = 10;</span><br><span class="line">ary.filter(function(x) &#123; return x === undefined;&#125;);</span><br></pre></td></tr></table></figure><p>答案是 []</p><p>看一篇文章理解稀疏数组</p><p>译 JavaScript中的稀疏数组与密集数组<br><br>Array/filter<br><br>我们来看一下 Array.prototype.filter 的 polyfill:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.prototype.filter) &#123;</span><br><span class="line">  Array.prototype.filter = function(fun/*, thisArg*/) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    if (this === void 0 || this === null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var t = Object(this);</span><br><span class="line">    var len = t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (typeof fun !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var res = [];</span><br><span class="line">    var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      if (i in t) &#123; // 注意这里!!!</span><br><span class="line">        var val = t[i];</span><br><span class="line">        if (fun.call(thisArg, val, i, t)) &#123;</span><br><span class="line">          res.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</p><p>0 in ary; =&gt; true<br><br>3 in ary; =&gt; false<br><br>10 in ary; =&gt; true<br><br>也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.</p><p><a name="1c19082a"></a></p><h2 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var two   = 0.2</span><br><span class="line">var one   = 0.1</span><br><span class="line">var eight = 0.8</span><br><span class="line">var six   = 0.6</span><br><span class="line">[two - one == one, eight - six == two]</span><br></pre></td></tr></table></figure><p>JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3<br><br>IEEE 754标准中的浮点数并不能精确地表达小数</p><p>那什么时候精准, 什么时候不经准呢? 笔者也不知道…</p><p>答案 [true, false]</p><p><a name="ac4aabec"></a></p><h2 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function showCase(value) &#123;</span><br><span class="line">    switch(value) &#123;</span><br><span class="line">    case &apos;A&apos;:</span><br><span class="line">        console.log(&apos;Case A&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case &apos;B&apos;:</span><br><span class="line">        console.log(&apos;Case B&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case undefined:</span><br><span class="line">        console.log(&apos;undefined&apos;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&apos;Do not know!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(new String(&apos;A&apos;));</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Statements/switch</li><li>String</li></ul><p>switch 是严格比较, String 实例和 字符串不一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s_prim = &apos;foo&apos;;</span><br><span class="line">var s_obj = new String(s_prim);</span><br><span class="line"></span><br><span class="line">console.log(typeof s_prim); // &quot;string&quot;</span><br><span class="line">console.log(typeof s_obj);  // &quot;object&quot;</span><br><span class="line">console.log(s_prim === s_obj); // false</span><br></pre></td></tr></table></figure><p>答案是 ‘Do not know!’</p><p><a name="88decc9a"></a></p><h2 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function showCase2(value) &#123;</span><br><span class="line">    switch(value) &#123;</span><br><span class="line">    case &apos;A&apos;:</span><br><span class="line">        console.log(&apos;Case A&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case &apos;B&apos;:</span><br><span class="line">        console.log(&apos;Case B&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case undefined:</span><br><span class="line">        console.log(&apos;undefined&apos;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&apos;Do not know!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase2(String(&apos;A&apos;));</span><br></pre></td></tr></table></figure><p>解释:<br><br>String(x) does not create an object but does return a string, i.e. typeof String(1) === “string”</p><p>还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.</p><p>答案 ‘Case A’</p><p><a name="e5bdb41c"></a></p><h2 id="第11题"><a href="#第11题" class="headerlink" title="第11题"></a>第11题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isOdd(num) &#123;</span><br><span class="line">    return num % 2 == 1;</span><br><span class="line">&#125;</span><br><span class="line">function isEven(num) &#123;</span><br><span class="line">    return num % 2 == 0;</span><br><span class="line">&#125;</span><br><span class="line">function isSane(num) &#123;</span><br><span class="line">    return isEven(num) || isOdd(num);</span><br><span class="line">&#125;</span><br><span class="line">var values = [7, 4, &apos;13&apos;, -9, Infinity];</span><br><span class="line">values.map(isSane);</span><br></pre></td></tr></table></figure><p>一个知识点</p><p>Arithmetic_Operators#Remainder<br><br>此题等价于</p><p>7 % 2 =&gt; 1<br><br>4 % 2 =&gt; 0<br><br>‘13’ % 2 =&gt; 1<br><br>-9 % % 2 =&gt; -1<br><br>Infinity % 2 =&gt; NaN<br><br>需要注意的是 余数的正负号随第一个操作数.</p><p>答案 [true, true, true, false, false]</p><p><a name="d6be270d"></a></p><h2 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(3, 8)</span><br><span class="line">parseInt(3, 2)</span><br><span class="line">parseInt(3, 0)</span><br></pre></td></tr></table></figure><p>第一个题讲过了, 答案 3, NaN, 3</p><p><a name="4226b3dd"></a></p><h2 id="第13题"><a href="#第13题" class="headerlink" title="第13题"></a>第13题</h2><p>Array.isArray( Array.prototype )<br><br>一个知识点:</p><p>Array/prototype<br><br>一个鲜为人知的实事: Array.prototype =&gt; [];</p><p>答案: true</p><p><a name="363c2f15"></a></p><h2 id="第14题"><a href="#第14题" class="headerlink" title="第14题"></a>第14题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [0];</span><br><span class="line">if ([0]) &#123;</span><br><span class="line">  console.log(a == true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&quot;wut&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript-Equality-Table<br><br>更新通过一张简单的图，让你彻底地、永久地搞懂JS的==运算 非常不错的一篇文章!<br><br>解析:</p><p>Boolean([0]) === true<br><br>[0] == true<br><br>true 转换为数字 =&gt; 1<br><br>[0] 转化为数字失败, 转化为字符串 ‘0’, 转化成数字 =&gt; 0<br><br>0 !== 1<br><br>答案: false</p><p><a name="b03895b5"></a></p><h2 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]==[]</span><br></pre></td></tr></table></figure><p>[] 是Object, 两个 Object 不相等</p><p>答案是 false</p><p><a name="04f071ac"></a></p><h2 id="第16题"><a href="#第16题" class="headerlink" title="第16题"></a>第16题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;5&apos; + 3</span><br><span class="line">&apos;5&apos; - 3</span><br></pre></td></tr></table></figure><p>两个知识点:</p><ul><li>Arithmetic_Operators#Addition</li><li>Arithmetic_Operators#Subtraction</li></ul><p>用来表示两个数的和或者字符串拼接, -表示两数之差.</p><p>请看例子, 体会区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;5&apos; + 3</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 + &apos;3&apos;</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 - &apos;3&apos;</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - 3</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - &apos;3&apos;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>也就是说 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接.</p><p>答案是 ‘53’, 2</p><p><a name="04355b99"></a></p><h2 id="第17题"><a href="#第17题" class="headerlink" title="第17题"></a>第17题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + - + + + - + 1</span><br></pre></td></tr></table></figure><p>这里应该是(倒着看)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 + (a)  =&gt; 2</span><br><span class="line">a = - (b) =&gt; 1</span><br><span class="line">b = + (c) =&gt; -1</span><br><span class="line">c = + (d) =&gt; -1</span><br><span class="line">d = + (e) =&gt; -1</span><br><span class="line">e = + (f) =&gt; -1</span><br><span class="line">f = - (g) =&gt; -1</span><br><span class="line">g = + 1   =&gt; 1</span><br></pre></td></tr></table></figure><p>所以答案 2</p><p><a name="b307f51e"></a></p><h2 id="第18题"><a href="#第18题" class="headerlink" title="第18题"></a>第18题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary = Array(3);</span><br><span class="line">ary[0]=2</span><br><span class="line">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</span><br></pre></td></tr></table></figure><p>稀疏数组. 同第7题.</p><p>题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.</p><p>所以答案是 [“1”, undefined × 2]</p><p>这里贴上 Array.prototype.map 的 polyfill.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map = function(callback, thisArg) &#123;</span><br><span class="line"></span><br><span class="line">        var T, A, k;</span><br><span class="line"></span><br><span class="line">        if (this == null) &#123;</span><br><span class="line">            throw new TypeError(&apos; this is null or not defined&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var O = Object(this);</span><br><span class="line">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class="line">        if (typeof callback !== &apos;function&apos;) &#123;</span><br><span class="line">            throw new TypeError(callback + &apos; is not a function&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arguments.length &gt; 1) &#123;</span><br><span class="line">            T = thisArg;</span><br><span class="line">        &#125;</span><br><span class="line">        A = new Array(len);</span><br><span class="line">        k = 0;</span><br><span class="line">        while (k &lt; len) &#123;</span><br><span class="line">            var kValue, mappedValue;</span><br><span class="line">            if (k in O) &#123;</span><br><span class="line">                kValue = O[k];</span><br><span class="line">                mappedValue = callback.call(T, kValue, k, O);</span><br><span class="line">                A[k] = mappedValue;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><a name="9323d012"></a></p><h2 id="第19题"><a href="#第19题" class="headerlink" title="第19题"></a>第19题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sidEffecting(ary) &#123;</span><br><span class="line">  ary[0] = ary[2];</span><br><span class="line">&#125;</span><br><span class="line">function bar(a,b,c) &#123;</span><br><span class="line">  c = 10</span><br><span class="line">  sidEffecting(arguments);</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1)</span><br></pre></td></tr></table></figure><p>这是一个大坑, 尤其是涉及到 ES6语法的时候</p><p>知识点:</p><p>Functions/arguments<br><br>首先 The arguments object is an Array-like object corresponding to the arguments passed to a function.</p><p>也就是说 arguments 是一个 object, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.</p><p>所以答案是 21.</p><p>然而!!!!!!</p><p>当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了…..</p><p>请看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sidEffecting(ary) &#123;</span><br><span class="line">  ary[0] = ary[2];</span><br><span class="line">&#125;</span><br><span class="line">function bar(a,b,c=3) &#123;</span><br><span class="line">  c = 10</span><br><span class="line">  sidEffecting(arguments);</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1)</span><br></pre></td></tr></table></figure><p>答案是 12 !!!!</p><p>请读者细细体会!!</p><p><a name="ec328372"></a></p><h2 id="第20题"><a href="#第20题" class="headerlink" title="第20题"></a>第20题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 111111111111111110000,</span><br><span class="line">    b = 1111;</span><br><span class="line">a + b;</span><br></pre></td></tr></table></figure><p>答案还是 111111111111111110000. 解释是 Lack of precision for numbers in JavaScript affects both small and big numbers. 但是笔者不是很明白……………. 请读者赐教!</p><p><a name="8e680b2c"></a></p><h2 id="第21题"><a href="#第21题" class="headerlink" title="第21题"></a>第21题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = [].reverse;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这个题有意思!</p><p>知识点:</p><ul><li>Array/reverse</li></ul><p>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</p><p>也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 window.</p><p>补充:</p><p><a href>stellar91 </a> 这个笔者实践了一下 发现 firefox 是 window, chrome 报错 VM190:2 Uncaught TypeError: Array.prototype.reverse called on null or undefined(…) 可能是实现不同, 在 chrome 中应该是对调用者做了检查. <br><br>答案是 window</p><p><a name="193cc324"></a></p><h2 id="第22题"><a href="#第22题" class="headerlink" title="第22题"></a>第22题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE &gt; 0</span><br></pre></td></tr></table></figure><p>true</p><p><a name="90106508"></a></p><h2 id="第23题"><a href="#第23题" class="headerlink" title="第23题"></a>第23题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</span><br></pre></td></tr></table></figure><p>这个题也还可以.</p><p>这个题会让人误以为是 2 &gt; 1 &amp;&amp; 2 &lt; 3 其实不是的.</p><p>这个题等价于</p><p>1 &lt; 2 =&gt; true;<br><br>true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;<br><br>3 &lt; 2 =&gt; false;<br><br>false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;<br><br>答案是 [true, true]</p><p><a name="e4881129"></a></p><h2 id="第24题"><a href="#第24题" class="headerlink" title="第24题"></a>第24题</h2><p>// the most classic wtf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 == [[[2]]]</span><br></pre></td></tr></table></figure><p>这个题我是猜的. 我猜的 true, 至于为什么…..</p><p>both objects get converted to strings and in both cases the resulting string is “2” 我不能信服…</p><p><a name="1c2a48a7"></a></p><h2 id="第25题"><a href="#第25题" class="headerlink" title="第25题"></a>第25题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.toString()</span><br><span class="line">3..toString()</span><br><span class="line">3...toString()</span><br></pre></td></tr></table></figure><p>这个题也挺逗, 我做对了 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f603.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt> 答案是 error, ‘3’, error</p><p>你如果换一个写法就更费解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">a.toString()</span><br></pre></td></tr></table></figure><p>这个答案就是 ‘3’;</p><p>为啥呢?</p><p>因为在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法啊!</p><p><a name="396db6e3"></a></p><h2 id="第26题"><a href="#第26题" class="headerlink" title="第26题"></a>第26题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var x = y = 1;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure><p>答案是 1, error</p><p>y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 ReferenceError</p><p><a name="17bd185d"></a></p><h2 id="第27题"><a href="#第27题" class="headerlink" title="第27题"></a>第27题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = /123/,</span><br><span class="line">    b = /123/;</span><br><span class="line">a == b</span><br><span class="line">a === b</span><br></pre></td></tr></table></figure><p>即使正则的字面量一致, 他们也不相等.</p><p>答案 false, false</p><p><a name="8146a75d"></a></p><h2 id="第28题"><a href="#第28题" class="headerlink" title="第28题"></a>第28题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3],</span><br><span class="line">    b = [1, 2, 3],</span><br><span class="line">    c = [1, 2, 4]</span><br><span class="line">a ==  b</span><br><span class="line">a === b</span><br><span class="line">a &gt;   c</span><br><span class="line">a &lt;   c</span><br></pre></td></tr></table></figure><p>字面量相等的数组也不相等.</p><p>数组在比较大小的时候按照字典序比较</p><p>答案 false, false, false, true</p><p><a name="68f766fa"></a></p><h2 id="第29题"><a href="#第29题" class="headerlink" title="第29题"></a>第29题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;, b = Object.prototype;</span><br><span class="line">[a.prototype === b, Object.getPrototypeOf(a) === b]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>Object/getPrototypeOf<br><br>只有 Function 拥有一个 prototype 的属性. 所以 a.prototype 为 undefined.</p><p>而 Object.getPrototypeOf(obj) 返回一个具体对象的原型(该对象的内部[[prototype]]值)</p><p>答案 false, true</p><p><a name="ffeb9319"></a></p><h2 id="第30题"><a href="#第30题" class="headerlink" title="第30题"></a>第30题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class="line">a === b</span><br><span class="line">f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.</span><br></pre></td></tr></table></figure><p>f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.</p><p>请看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === Object.getPrototypeOf(new f()) // true</span><br><span class="line">b === Function.prototype // true</span><br></pre></td></tr></table></figure><p>答案 false</p><p><a name="0ba0c1ef"></a></p><h2 id="第31题"><a href="#第31题" class="headerlink" title="第31题"></a>第31题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; &#125;</span><br><span class="line">var oldName = foo.name;</span><br><span class="line">foo.name = &quot;bar&quot;;</span><br><span class="line">[oldName, foo.name]</span><br></pre></td></tr></table></figure><p>答案 [‘foo’, ‘foo’]</p><p>知识点:</p><p>Function/name<br><br>因为函数的名字不可变.</p><p><a name="e5b74cc4"></a></p><h2 id="第32题"><a href="#第32题" class="headerlink" title="第32题"></a>第32题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1 2 3&quot;.replace(/\d/g, parseInt)</span><br></pre></td></tr></table></figure><p>知识点:</p><p>String/replace#Specifying_a_function_as_a_parameter<br><br>str.replace(regexp|substr, newSubStr|function)</p><p>如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数</p><p>match 首先是匹配的字符串<br><br>p1, p2 …. 然后是正则的分组<br><br>offset match 匹配的index<br><br>string 整个字符串<br><br>由于题目中的正则没有分组, 所以等价于问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0)</span><br><span class="line">parseInt(&apos;2&apos;, 2)</span><br><span class="line">parseInt(&apos;3&apos;, 4)</span><br></pre></td></tr></table></figure><p>答案: 1, NaN, 3</p><p><a name="32e50656"></a></p><h2 id="第33题"><a href="#第33题" class="headerlink" title="第33题"></a>第33题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">var parent = Object.getPrototypeOf(f);</span><br><span class="line">f.name // ?</span><br><span class="line">parent.name // ?</span><br><span class="line">typeof eval(f.name) // ?</span><br><span class="line">typeof eval(parent.name) //  ?</span><br></pre></td></tr></table></figure><p>先说以下答案 ‘f’, ‘Empty’, ‘function’, error 这个答案并不重要…..</p><p>这里第一小问和第三小问很简单不解释了.</p><p>第二小问笔者在自己的浏览器测试的时候是 ‘’, 第四问是 ‘undefined’</p><p>所以应该是平台相关的. 这里明白 parent === Function.prototype 就好了.</p><p><a name="66c25b05"></a></p><h2 id="第34题"><a href="#第34题" class="headerlink" title="第34题"></a>第34题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var lowerCaseOnly =  /^[a-z]+$/;</span><br><span class="line">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>RegExp/test<br><br>这里 test 函数会将参数转为字符串. ‘nul’, ‘undefined’ 自然都是全小写了</p><p>答案: true, true</p><p><a name="6fdb4ece"></a></p><h2 id="第35题"><a href="#第35题" class="headerlink" title="第35题"></a>第35题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[,,,].join(&quot;, &quot;)</span><br><span class="line">[,,,] =&gt; [undefined × 3]</span><br></pre></td></tr></table></figure><p>因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)</p><p>答案: “, , “</p><p><a name="83ddc935"></a></p><h2 id="第36题"><a href="#第36题" class="headerlink" title="第36题"></a>第36题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</span><br><span class="line">a.class</span><br></pre></td></tr></table></figure><p>这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了)</p><p>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’]</p><p><a name="a4ba204a"></a></p><h2 id="第37题"><a href="#第37题" class="headerlink" title="第37题"></a>第37题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = new Date(&quot;epoch&quot;)</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li>Date</li><li>Date/parse</li></ul><p>简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.</p><p>另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 Invalid Date.</p><p>答案 Invalid Date</p><p><a name="6a4d0417"></a></p><h2 id="第38题"><a href="#第38题" class="headerlink" title="第38题"></a>第38题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = Function.length,</span><br><span class="line">    b = new Function().length</span><br><span class="line">a === b</span><br></pre></td></tr></table></figure><p>我们知道一个function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0.</p><p>另外 Function.length 定义为1……</p><p>所以不相等…….答案 false</p><p><a name="9d1c9a97"></a></p><h2 id="第39题"><a href="#第39题" class="headerlink" title="第39题"></a>第39题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = Date(0);</span><br><span class="line">var b = new Date(0);</span><br><span class="line">var c = new Date();</span><br><span class="line">[a === b, b === c, a === c]</span><br></pre></td></tr></table></figure><p>还是关于Date 的题, 需要注意的是</p><p>如果不传参数等价于当前时间.<br><br>如果是函数调用 返回一个字符串.<br><br>答案 false, false, false</p><p><a name="8b9f16c2"></a></p><h2 id="第40题"><a href="#第40题" class="headerlink" title="第40题"></a>第40题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var min = Math.min(), max = Math.max()</span><br><span class="line">min &lt; max</span><br></pre></td></tr></table></figure><p>知识点:</p><p>Math/min<br><br>Math/max<br><br>有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f606.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>答案: false</p><p><a name="23237300"></a></p><h2 id="第41题"><a href="#第41题" class="headerlink" title="第41题"></a>第41题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function captureOne(re, str) &#123;</span><br><span class="line">  var match = re.exec(str);</span><br><span class="line">  return match &amp;&amp; match[1];</span><br><span class="line">&#125;</span><br><span class="line">var numRe  = /num=(\d+)/ig,</span><br><span class="line">    wordRe = /word=(\w+)/i,</span><br><span class="line">    a1 = captureOne(numRe,  &quot;num=1&quot;),</span><br><span class="line">    a2 = captureOne(wordRe, &quot;word=1&quot;),</span><br><span class="line">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</span><br><span class="line">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</span><br><span class="line">[a1 === a2, a3 === a4]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>RegExp/exec<br><br>通俗的讲</p><p>因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会</p><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myRe = /ab*/g;</span><br><span class="line">var str = &apos;abbcdefabh&apos;;</span><br><span class="line">var myArray;</span><br><span class="line">while ((myArray = myRe.exec(str)) !== null) &#123;</span><br><span class="line">  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</span><br><span class="line">  msg += &apos;Next match starts at &apos; + myRe.lastIndex;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">// Found abb. Next match starts at 3</span><br><span class="line">// Found ab. Next match starts at 9</span><br></pre></td></tr></table></figure><p>所以 a1 = ‘1’; a2 = ‘1’; a3 = null; a4 = ‘2’</p><p>答案 [true, false]</p><p><a name="8876f8c5"></a></p><h2 id="第42题"><a href="#第42题" class="headerlink" title="第42题"></a>第42题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Date(&quot;2014-03-19&quot;),</span><br><span class="line">    b = new Date(2014, 03, 19);</span><br><span class="line">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</span><br></pre></td></tr></table></figure><p>这个….</p><p>JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.getDay()</span><br><span class="line">3</span><br><span class="line">b.getDay()</span><br><span class="line">6</span><br><span class="line">a.getMonth()</span><br><span class="line">2</span><br><span class="line">b.getMonth()</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>都是套路!</p><p>答案 [false, false]</p><p><a name="9f4762dd"></a></p><h2 id="第43题"><a href="#第43题" class="headerlink" title="第43题"></a>第43题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</span><br><span class="line">  &apos;a gif file&apos;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &apos;not a gif file&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点:</p><p>String/match<br><br>String.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义<br><br>那么 /gif 就匹配了 /.gif/</p><p>答案: ‘a gif file’</p><p><a name="323e4f13"></a></p><h2 id="第44题"><a href="#第44题" class="headerlink" title="第44题"></a>第44题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">function bar(a) &#123;</span><br><span class="line">    var a = &apos;bye&apos;;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</span><br></pre></td></tr></table></figure><p>在两个函数里, a作为参数其实已经声明了, 所以 var a; var a = ‘bye’ 其实就是 a; a =’bye’</p><p>所以答案 ‘hello’, ‘bye’</p><p>全部结束!</p><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于笔者水平有限, 如果解释有误, 还望指出 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f604.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>通过整理, 笔者发现绝大部分题目都是因为自己对于基础知识或者说某个 API 的参数理解偏差才做错的.</p><p>笔者的重灾区在原型那一块, 所以这次被虐和整理还是很有意义呀.</p><p>笔者相信 坚实的基础是深入编程的前提. 所以基础书还是要常看啊 <img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f439.svg#align=left&display=inline&height=18&originHeight=150&originWidth=150&status=done&width=18" alt></p><p>最后这些变态题现在看看还变态嘛?</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猜数字游戏算法</title>
      <link href="/2018/03/16/%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/03/16/%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a name="5f5f8ea7"></a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有猜数字游戏如下</p><blockquote><p>庄家预先写下一个四位数字（每位数字各不相同），玩家每次随机猜一个数字，庄家告知玩家猜对了几A几B（A代表数字和位置都相同，B代表包含该数字但位置不同，比如如果庄家写的是3514，玩家猜的是3165，庄家会回答1A2B），玩家继续猜，直到猜中为止。如果超过5轮没猜中，则玩家输，否则玩家赢。请为玩家设计一个猜数字的算法，确保玩家能够大概率胜。<br><br>例如：庄家写下9876，玩家第一次猜0123，庄家回复0A0B；玩家继续猜4567，庄家恢复0A2B；依次下去，知道玩家猜中9876为止。</p></blockquote><a id="more"></a><p>一道很有意思的题目，网上搜索下，发现有很多解法，主流两种</p><ol><li>筛选法</li><li>信息熵法</li></ol><p><a name="63ae59cd"></a></p><h2 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h2><p>筛选法原理很简单，首先我们需要知道庄家所有可能结果的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>*<span class="number">9</span>*<span class="number">8</span>*<span class="number">7</span> === <span class="number">5040</span>  <span class="comment">// 总共有5040个可能结果</span></span><br></pre></td></tr></table></figure><p>然后，玩家猜一个数字，和庄家数字对比后得到一个反馈结果<code>某A某B</code></p><p>这时候，我们把所有5040个可能的结果和玩家数字对比，再从中过滤出和<code>某A某B</code>一样反馈的结果集，那么这个<strong>结果集中一定包含了庄家数字</strong>，这就是一次过滤，排除很多无关的数据。</p><p>然后在第一次过滤出来的结果集中随机取一个数字，用这个数字和庄家对比进行第二次猜测，用上面的方法在上一次的过滤结果中再次过滤，得到第二次过滤结果。</p><p>循环过滤，最后只剩一个结果。</p><p><a name="a22fc877"></a></p><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p>首先是得到所有可能数字的集合，本质上是0-9999之间每位不重复的数字集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [] <span class="comment">// 集合数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> str</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">        str = <span class="string">'0'</span> + i <span class="comment">// 例子： 0987 这种特殊情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = <span class="string">''</span> + i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Set</span>(arr).size !== <span class="number">4</span>) <span class="keyword">continue</span> <span class="comment">// 判断size === 4，表示没有重复数字</span></span><br><span class="line">    data.push(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure><p>两串数字对比并得到反馈的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analyse</span>(<span class="params">basicArr, compareArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    basicArr.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == compareArr[index]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> A = count</span><br><span class="line">    <span class="keyword">const</span> B = (compareArr.length + basicArr.length) - <span class="keyword">new</span> <span class="built_in">Set</span>([...basicArr, ...compareArr]).size - A</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`A<span class="subst">$&#123;A&#125;</span>B<span class="subst">$&#123;B&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    analyse([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>])  <span class="comment">// A1B1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>过滤函数那部分就简单了，略。</p><p>整体代码如下，大概率在第五次过滤就只有一个结果存在了，少部分在5次前就出来了，部分需要更多次过滤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数用于分析两个数组之间的反馈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analyse</span>(<span class="params">basicArr, compareArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    basicArr.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == compareArr[index]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> A = count</span><br><span class="line">    <span class="keyword">const</span> B = (compareArr.length + basicArr.length) - <span class="keyword">new</span> <span class="built_in">Set</span>([...basicArr, ...compareArr]).size - A</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`A<span class="subst">$&#123;A&#125;</span>B<span class="subst">$&#123;B&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认以结果集第一个数据为猜测值, 最后根据猜测反馈的值过滤出所有符合反馈的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">preResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> guess = preResult[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> re = analyse(store, guess)</span><br><span class="line">    <span class="keyword">const</span> filterResult = preResult.filter(<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (analyse(guess, arr) == re) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> filterResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="keyword">let</span> data = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下for循环用来将符合猜规则的数据存放到data变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> str</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">        str = <span class="string">'0'</span> + i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = <span class="string">''</span> + i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Set</span>(arr).size !== <span class="number">4</span>) <span class="keyword">continue</span></span><br><span class="line">    data.push(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成庄家数组</span></span><br><span class="line"><span class="keyword">const</span> store = data[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * data.length) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'庄家数据: '</span>, store)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下每一次filter包含一次猜测,返回可能的结果集,在结果集中重复过滤,大概率会在第五次猜测后得到唯一的数据, 第六次概率更高</span></span><br><span class="line"><span class="keyword">const</span> filterResult1 = filter(data)</span><br><span class="line"><span class="keyword">const</span> filterResult2 = filter(filterResult1)</span><br><span class="line"><span class="keyword">const</span> filterResult3 = filter(filterResult2)</span><br><span class="line"><span class="keyword">const</span> filterResult4 = filter(filterResult3)</span><br><span class="line"><span class="keyword">const</span> filterResult5 = filter(filterResult4)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterResult5)</span><br></pre></td></tr></table></figure><p><a name="895b4ac6"></a></p><h2 id="信息熵法"><a href="#信息熵法" class="headerlink" title="信息熵法"></a>信息熵法</h2><p>待以后有空补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于原型链</title>
      <link href="/2018/03/14/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/03/14/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><a name="9f4eb5bf"></a></p><h2 id="以下这张图，基本解释了所有的原型关系"><a href="#以下这张图，基本解释了所有的原型关系" class="headerlink" title="以下这张图，基本解释了所有的原型关系"></a>以下这张图，基本解释了所有的原型关系</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/280778/1551716465866-8a074836-eba5-48e8-9289-f961b243f2b1.png#align=left&display=inline&height=586&name=image.png&originHeight=586&originWidth=520&size=173051&status=done&width=520" alt="image.png"></p><p>核心要素是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line">foo.__proto__ == foo.constructor.prototype == Foo.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// .__proto__ 可以简单理解成 .construstor.prototype 的简写</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>但本质上<code>__proto__</code>不等于<code>.constructor.prototype</code>，当我把对象的<code>constructor</code>置为<code>null</code>，<code>.__proto__</code>还是能够读到，但是<code>.constructor.prototype</code>直接报错了。这里这么说只是为了方便理解<br><br>说到底<code>.__proto__</code>就是这个对象的构造函数的原型。</p><p>理解了这个就能理解上面图示的所有的关系了。</p><hr><p><a name="b13987ed"></a></p><h2 id="以下有助于理解几个基类之间的关系"><a href="#以下有助于理解几个基类之间的关系" class="headerlink" title="以下有助于理解几个基类之间的关系"></a>以下有助于理解几个基类之间的关系</h2><p><code>instanceof</code>操作符</p><p>instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设 L instanceof R </span><br><span class="line">//通过判断</span><br><span class="line"> L.__proto__.__proto__ ..... === R.prototype ？</span><br><span class="line"> //最终返回true or false</span><br></pre></td></tr></table></figure><p>也就是沿着L的<code>__proto__</code>一直寻找到原型链末端，直到等于<code>R.prototype</code>为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function instanceof Object // true </span><br><span class="line"> Object instanceof Function // true </span><br><span class="line"> Function instanceof Function //true</span><br><span class="line"> Object instanceof Object // true</span><br><span class="line"> Number instanceof Number //false</span><br></pre></td></tr></table></figure><p><a name="30bacd56"></a></p><h2 id="总结了下"><a href="#总结了下" class="headerlink" title="总结了下"></a>总结了下</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.constructor === <span class="function"><span class="keyword">function</span> <span class="title">Function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor === <span class="function"><span class="keyword">function</span> <span class="title">Function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个需要特殊注意一下， 记住这个基本上能把所有的东西都推理出来了。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype === functoin ()&#123; native code &#125; <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor === Funtion <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.constructor.prototype === <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; native code &#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...无限循环</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// 原型链的终点</span></span><br></pre></td></tr></table></figure><p><a name="68d14dba"></a></p><h2 id="关于-proto"><a href="#关于-proto" class="headerlink" title="关于__proto__"></a>关于<code>__proto__</code></h2><p><code>__proto__</code> 是内部的<strong>构造函数原型对象</strong>， 一般情况下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === obj.constructor.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是<code>__proto__</code>不会因为你在对象的prototype中更改constructor而改变。它总是指向对象被创建时的那个<code>constructor</code> function ， 举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog; <span class="comment">// 在继承的时候，这里改变了prototype.constructor，但是不影响__proto__的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog() <span class="keyword">instanceof</span> Animal <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Dog() <span class="keyword">instanceof</span> Dog <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据以上 instanceof 的原理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.__proto__ === Animal.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里__proto__和constructor.prototype的结果就不同, 一定要搞清楚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.constructor.prototype ===  Animal.prototype <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> Dog().__proto__.constructor.prototype === Dog.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>部分内容摘自<br><br>作者：苏墨橘<br><br>链接：<a href="https://www.zhihu.com/question/34183746/answer/59043879" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746/answer/59043879</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
