<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu 18.04开启bbr]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2Fubuntu%2018.04%E5%BC%80%E5%90%AFbbr%2F</url>
    <content type="text"><![CDATA[说明：Ubuntu 18.04前几天发布了，改变挺大的，内核也直接升到了正式版4.15，而BBR内核要求为4.9，也就是说满足了，所以我们不需要换内核就可以很快的开启BBR，这里简单说下方法。 方法1、修改系统变量 echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf 2、保存生效 sysctl -p 3、查看内核是否已开启BBR sysctl net.ipv4.tcp_available_congestion_control 显示以下即已开启： # sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 4、查看BBR是否启动 lsmod | grep bbr 显示以下即启动成功： # lsmod | grep bbrtcp_bbr 20480 14 原文链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xshell调整tmux大小无效问题]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FXshell%E8%B0%83%E6%95%B4tmux%E5%A4%A7%E5%B0%8F%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由screen转tmux，使用的时候发现tmux的pane大小只能左右调节不能上下调节，各种搜索后发现是xshell的问题，xshell这个坑竟然不响应ctrl+up和ctrl+down。。。 两个组合键输出的特殊字符是[1;5A和[1;5B，其中是一个代表esc的特殊字符。复制输出的字符串，xshell工具-&gt;选项-&gt;键盘和鼠标-&gt;编辑-&gt;新建，按ctrl+up，类型选择发送字符串，粘贴刚才复制的对应字符串，完成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[tmux常用命令以及快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2Ftmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[命令行 tmux new[-session] -s $session_name -d 新建会话(-d 是否在后台) tmux new -s name -n $window_name 新建会话及窗口 tmux at[tach] -t session 重新连接(-t 后接会话名称) tmux ls 显示保存的会话 tmux kill-session -t $session_name 删除会话 内部命令prefix: ctrl+bprefix `&#123; / &#125;` 左右pane交换prefix `&quot;`: 上下分割prefix `%`: 左右分割prefix `方向键`: focus到相应的panel上prefix `o`: focus 到下一个pannel上 prefix `d`: 推出并保存工作区 `tmux attach` 恢复prefix `&amp;`: 关闭工作区，无法保存prefix `:kill-session`: 关闭当前sessionprefix `d`: 临时退出sessionprefix `:kill-server`: 关闭所有session]]></content>
  </entry>
  <entry>
    <title><![CDATA[NERD tree 配置命令以及快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FNERD%20tree%20%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[NERD tree 配置使用F2快速展开或隐藏它打开vim时自动展开NERDTree autocmd vimenter * if !argc() | NERDTree | endif 如果窗口除了NERDTree没有其他文件时，自动关闭，可以减少多次按:q autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTreeType") &amp;&amp; b:NERDTreeType == "primary") | q | endif 使用F2快速展开或隐藏它 map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt; 命令:tabnew [++opt选项] ［＋cmd］ 文件 建立对指定文件新的tab:tabc 关闭当前的 tab:tabo 关闭所有其他的 tab:tabs 查看所有打开的 tab:tabp 前一个 tab:tabn 后一个 tab 快捷键shift + a 侧边栏宽度放大，再按一下恢复ctrl + w + h 光标 focus 左侧树形目录ctrl + w + l 光标 focus 右侧文件显示窗口ctrl + w + w 光标自动在左右侧窗口切换 #！！！ctrl + w + r 移动当前窗口的布局位置o 在已有窗口中打开文件、目录或书签，并跳到该窗口go 在已有窗口 中打开文件、目录或书签，但不跳到该窗口t 在新 Tab 中打开选中文件/书签，并跳到新 TabT 在新 Tab 中打开选中文件/书签，但不跳到新 Tabi split 一个新窗口打开选中文件，并跳到该窗口gi split 一个新窗口打开选中文件，但不跳到该窗口s vsplit 一个新窗口打开选中文件，并跳到该窗口gs vsplit 一个新 窗口打开选中文件，但不跳到该窗口! 执行当前文件O 递归打开选中 结点下的所有目录x 合拢选中结点的父目录X 递归 合拢选中结点下的所有目录e Edit the current dif双击 相当于 NERDTree-o中键 对文件相当于 NERDTree-i，对目录相当于 NERDTree-eD 删除当前书签P 跳到根结点p 跳到父结点K 跳到当前目录下同级的第一个结点J 跳到当前目录下同级的最后一个结点k 跳到当前目录下同级的前一个结点j 跳到当前目录下同级的后一个结点C 将选中目录或选中文件的父目录设为根结点u 将当前根结点的父目录设为根目录，并变成合拢原根结点U 将当前根结点的父目录设为根目录，但保持展开原根结点r 递归刷新选中目录R 递归刷新根结点m 显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等cd 将 CWD 设为选中目录I 切换是否显示隐藏文件f 切换是否使用文件过滤器F 切换是否显示文件B 切换是否显示书签q 关闭 NerdTree 窗口? 切换是否显示 Quick Help标准模式下：gT 前一个 tabgt 后一个 tabMacVim 还可以借助快捷键来完成 tab 的关闭、切换cmd+w 关闭当前的 tabcmd+&#123; 前一个 tabcmd+&#125; 后一个 tab ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[VIM常用快捷键]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FVIM%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[v：按字符选择。经常使用的模式，所以亲自尝试一下它。V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。一、移动光标1、左移h、右移l、下移j、上移k2、向下翻页ctrl + f，向上翻页ctrl + b3、向下翻半页ctrl + d，向上翻半页ctrl + u4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^5、移动光标到下一个句子 ），移动光标到上一个句子（6、移动到段首&#123;，移动到段尾&#125;7、移动到下一个词w，移动到上一个词b8、移动到文档开始gg，移动到文档结束G9、移动到匹配的&#123;&#125;.().[]处%10、跳到第n行 ngg 或 nG 或 :n11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L12、读取当前字符，并移动到本屏幕内下一次出现的地方 *13、读取当前字符，并移动到本屏幕内上一次出现的地方 #二、查找替换1、光标向后查找关键字 #或者g#2、光标向前查找关键字 *或者g*3、当前行查找字符 fx, Fx, tx, Tx4、基本替换 :s/s1/s2 （将下一个s1替换为s2）5、全部替换 :%s/s1/s26、只替换当前行 :s/s1/s2/g7、替换某些行 :n1,n2 s/s1/s2/g8、搜索模式为 /string，搜索下一处为n，搜索上一处为N9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母10、移动到某标签处 `x，1旁边的键11、移动到上次编辑文件的位置 `.PS：.代表一个任意字符 *代表一个或多个字符的重复 正则表达式的内容将会在后续文章中整理三、编辑操作1、光标后插入a, 行尾插入A2、后插一行插入o，前插一行插入O3、删除字符插入s， 删除正行插入S4、光标前插入i，行首插入I5、删除一行dd，删除后进入插入模式cc或者S6、删除一个单词dw，删除一个单词进入插入模式cw7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl8、粘贴p，交换两个字符xp，交换两行ddp9、复制y，复制一行yy10、撤销u，重做ctrl + r，重复.11、智能提示 ctrl + n 或者 ctrl + p12、删除motion跨过的字符，删除并进入插入模式 c&#123;motion&#125;13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx15、删除motion跨过的字符，删除但不进入插入模式 d&#123;motion&#125;16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx18、如果只是复制的情况时，将12-17条中的c或d改为y19、删除到行尾可以使用D或C20、拷贝当前行 yy或者Y21、删除当前字符 x22、粘贴 p23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy24、重复执行上一个作用使用.25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进27、 &gt;&gt; 缩进所有选择的代码28、 &lt;&lt; 反缩进所有选择的代码29、gd 移动到光标所处的函数或变量的定义处30、K 在man里搜索光标所在的词31、合并两行 J32、若不想保存文件，而重新打开 :e!33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换四、窗口操作1、分隔一个窗口:split或者:vsplit2、创建一个窗口:new或者:vnew3、在新窗口打开文件:sf &#123;filename&#125;4、关闭当前窗口:close5、仅保留当前窗口:only6、到左边窗口 ctrl + w, h7、到右边窗口 ctrl + w, l8、到上边窗口 ctrl + w, k9、到下边窗口 ctrl + w, j10、到顶部窗口 ctrl + w, t11、到底部窗口 ctrl + w, b五、宏操作1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中2、@[a-z]执行寄存器[a-z]中的操作3、@@执行最近一次记录的宏操作六、可视操作1、进入块可视模式 ctrl + v2、进入字符可视模式 v3、进入行可视模式 V4、删除选定的块 d5、删除选定的块然后进入插入模式 c6、在选中的块同是插入相同的字符 I&lt;String&gt;ESC七、跳到声明1、[[ 向前跳到顶格第一个&#123; 2、[] 向前跳到顶格第一个&#125;3、]] 向后跳到顶格的第一个&#123;4、]] 向后跳到顶格的第一个&#125;5、[&#123; 跳到本代码块的开头6、]&#125; 跳到本代码块的结尾八、挂起操作1、挂起Vim ctrl + z 或者 :suspend2、查看任务 在shell中输入 jobs3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）4、执行shell命令 :!command5、开启shell命令 :shell，退出该shell exit6、保存vim状态 :mksession name.vim7、恢复vim状态 :source name.vim8、启动vim时恢复状态 vim -S name.vim]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux无损调整分区大小]]></title>
    <url>%2F2019%2F03%2F04%2Fyuque%2FLinux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[场景500G 硬盘 100MB `boot`分区 |8G `swap`分区 |450G `/`分区 我需要将/home分区单独提取一个分区出来，即变成 100MB `boot`分区 |8G `swap`分区 |100G `/`分区 |350G `/home`分区 步骤 sudo e2fsck -fy /dev/sda3 // f 是表示检查，y表示一直确认，直到修复完 sudo resize2fs /dev/sda3 100G //将文件系统调整到50G（不太明白文件系统大小和分区大小的关系） sudo fdisk /dev/sda // 使用fdisk进行分区 首先输入p，查看要调整分区（sda3）的start序号（重要） 输入 d 删除要sda3，选择3 输入 n 添加一个主分区，分区号选择3 选择start地址，就是刚才查看的地址（一般不用修改，默认就是刚才的值） 选择分区容量，输入+100G 然后再新建一个分区，输入n，选择p（主分区），选择默认起点，再选择默认终点 按w保存分区表 这里有可能会报错，什么device被占用之类的错误 使用 partprobe /dev/sda命令重载/dev/sda 重载分区表，（命令成功界面没有显示） sudo e2fsck -fy /dev/sda3 修复sda3分区 sudo resize2fs /dev/sda3 检查一下有没有问题 sda3分区已经没有问题了，数据全部都保留着。 格式化sda4 sudo mkfs.ext4 /dev/sda4 然后就是迁移所有/home数据到sda4 在fstab中添加一行 UUID=xxxxxxxxxxxxxxx /home ext4 defaults 0 0 开机后使用sudo chown -R username:username /home/fan，否则由于权限问题导致无法登录 大功告成！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux创建开机启动服务]]></title>
    <url>%2F2019%2F03%2F03%2Fyuque%2FLinux%E5%88%9B%E5%BB%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[需求使用linux离不开ss，每次都需要手动输入命令开启，很麻烦，所以需要创建开机就启动的服务。 前提假设我们有一段需要开机启动的服务脚本/home/username/document/ss-local.sh如下 ss-local -c /home/username/document/ssconfig.json 创建服务（两种方式） 1. 创建成系统服务然后在/etc/init.d/新建ss-local文件，注意这个文件的写法 #!/bin/sh### BEGIN INIT INFO# Provides: ss-local // 名字要和文件名一样# Required-Start: $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5 # Default-Stop: 0 1 6# Short-Description: local shadowsocks service### END INIT INFOset -ePATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin. /lib/lsb/init-functionsNAME=ss-localDEAMON=/home/username/document/ss-local.sh # 注意设置正确的脚本路径start_sslocal() &#123; start-stop-daemon --start --background --name $NAME --exec $DEAMON&#125;stop_sslocal() &#123; start-stop-daemon --stop --name $NAME&#125;case "$1" in start|"") start_sslocal ;; restart|reload|force-reload) stop_sslocal ;; stop) exit 0 ;; *) esac 将文件的权限置为755 sudo chmod 755 ss-local 将服务文件设置为开机启动 sudo update-rc.d ss-local defaults 启动服务 sudo systemctl start ss-local 2. 创建成systemd服务定位到/usr/lib/systemd/system目录（如果没有就新建），新建ss-local.service。 [Unit]#定义描述Description=The ss-local service#指定了在systemd在执行完那些target之后再启动该服务After=network.target remote-fs.target nss-lookup.target[Service]#定义Service 的运行type，一般是forking，就是后台运行Type=simple#以下定义systemctl start |stop |reload *.service 的每个执行方法，具体命令#需要&gt;写绝对路径ExecStart=/home/fan/Documents/ss/ss-local.sh#创建私有的内存临时空间PrivateTmp=true[Install]WantedBy=multi-user.target 然后就可以设置开机启动了 # 开机启动sudo systemctl enable ss-local.service# 启动服务sudo systemctl start ss-local.service 完]]></content>
  </entry>
</search>
